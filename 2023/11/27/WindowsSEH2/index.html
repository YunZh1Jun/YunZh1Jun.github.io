<!DOCTYPE html>
<html lang="zh-cn">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>Windows-SEH学习笔记（2） - 云之君&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/img/fav/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
    
<script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
 
  

  
<meta name="generator" content="Hexo 5.4.2"></head>
    <body data-color-scheme="auto">
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">云之君&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">主页</a>
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/CTF">CTF</a>
            
            
            
            <a class="nav-item" href="/Learn">Learn</a>
            
            
            
            <a class="nav-item" href="/Diary">Diary</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/YunZh1Jun" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            
            
            
            
            
            
            
            
            <span>November</span>
            
            
            <span>27,</span>
            <span>2023</span>
        </div>
        

        <h2 class="title">Windows-SEH学习笔记（2）</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p><del>咕了一年终于写完了，泪目……</del><br><del><strong>由于笔者写完实在懒得再看一遍，所以有的地方有可能会有小问题……如果读者有某部分不理解，一定是笔者的问题，绝对与读者本人水平无关，一切问题都怪笔者</strong></del></p>
<p>翻译链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/aa13058219642/article/details/80253609">https://blog.csdn.net/aa13058219642/article/details/80253609</a><br>存档英文原文：<a target="_blank" rel="noopener" href="https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm">https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm</a><br>强烈推荐阅读原文……本文只是一些简略的东西<del>以及我的一些垃圾吐槽和sb问题</del>。以及以及现在用的已经是__except_handler4了，而这篇文章大部分讲述还用的是__except_handler3，我会掺杂一丢丢关于__except_handler4部分的更新<del>（以后有闲心了再多补点）</del>，原文中一些（我感觉）奇怪的地方我也会做简略说明。</p>
<h2 id="再分析"><a href="#再分析" class="headerlink" title="再分析"></a>再分析</h2><p>_except_handler异常回调函数接收操作系统传递的关于异常的信息，使用这些信息来决定下一步做什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常回调函数</span></span><br><span class="line"> EXCEPTION_DISPOSITION</span><br><span class="line"> __cdecl _except_handler(</span><br><span class="line">     <span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">     <span class="type">void</span> * EstablisherFrame,                               <span class="comment">//指向establisher帧结构</span></span><br><span class="line">     <span class="keyword">struct</span> _CONTEXT *ContextRecord,                        <span class="comment">//指向CONTEXT结构</span></span><br><span class="line">     <span class="type">void</span> * DispatcherContext</span><br><span class="line">     );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">   DWORD ExceptionCode;                                        <span class="comment">//异常代码</span></span><br><span class="line">   DWORD ExceptionFlags;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">   PVOID ExceptionAddress;                                     <span class="comment">//异常发生的地址</span></span><br><span class="line">   DWORD NumberParameters;</span><br><span class="line">   DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">   &#125;  EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>

<p>那么发生错误时操作系统怎么知道去哪里调用这个异常回调函数？答案是一个称为EXCEPTION_REGISTRATION的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span></span><br><span class="line">    <span class="comment">//指向下一个 EXCEPTION_REGISTRATION_RECORD</span></span><br><span class="line">    PEXCEPTION_DISPOSITION Handler;  </span><br><span class="line">    <span class="comment">//指向异常处理函数</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD,*PEXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>

<p>那么操作系统到哪里去找EXCEPTION_REGISTRATION？要回答这个问题，首先要记住<strong>结构化异常处理是基于线程的</strong>。线程信息块（TEB）的第一个DWORD就是指向EXCEPTION_REGISTRATION结构的指针。在intel处理器的win32平台上，FS寄存器指向当前TEB，所以FS:[0]就是指向EXCEPTION_REGISTRATION结构的指针。</p>
<p>问题到此清楚。异常发生时，系统找到当前线程的TEB，获取指向EXCEPTION_REGISTRATION结构的指针，在这个结构中找到指向异常回调函数_except_handler的指针，然后调用它。</p>
<p>一个简单的用于描述以上过程的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==================================================</span></span><br><span class="line"><span class="comment">// MYSEH - Matt Pietrek 1997</span></span><br><span class="line"><span class="comment">// Microsoft Systems Journal, January 1997</span></span><br><span class="line"><span class="comment">// FILE: MYSEH.CPP</span></span><br><span class="line"><span class="comment">// To compile: CL MYSEH.CPP</span></span><br><span class="line"><span class="comment">//==================================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">DWORD scratch;</span><br><span class="line"> </span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl</span><br><span class="line">_except_handler(</span><br><span class="line"><span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line"><span class="type">void</span> * EstablisherFrame,</span><br><span class="line"><span class="keyword">struct</span> _CONTEXT *ContextRecord,</span><br><span class="line"><span class="type">void</span> * DispatcherContext )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Indicate that we made it to our exception handler</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Hello from an exception handler\n&quot;</span> );</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Change EAX in the context record so that it points to someplace</span></span><br><span class="line">    <span class="comment">// where we can successfully write</span></span><br><span class="line">    ContextRecord-&gt;Eax = (DWORD)&amp;scratch;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Tell the OS to restart the faulting instruction</span></span><br><span class="line">    <span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD handler = (DWORD)_except_handler;</span><br><span class="line">     </span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build EXCEPTION_REGISTRATION record:</span></span><br><span class="line">        push handler <span class="comment">// Address of handler function</span></span><br><span class="line">        push FS:[<span class="number">0</span>] <span class="comment">// Address of previous handler</span></span><br><span class="line">        mov FS:[<span class="number">0</span>],ESP <span class="comment">// Install new EXECEPTION_REGISTRATION</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax,<span class="number">0</span> <span class="comment">// Zero out EAX</span></span><br><span class="line">        mov [eax], <span class="number">1</span> <span class="comment">// Write to EAX to deliberately cause a fault</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;After writing!\n&quot;</span> );</span><br><span class="line">     </span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove our EXECEPTION_REGISTRATION record</span></span><br><span class="line">        mov eax,[ESP] <span class="comment">// Get pointer to previous record</span></span><br><span class="line">        mov FS:[<span class="number">0</span>], EAX <span class="comment">// Install previous record</span></span><br><span class="line">        add esp, <span class="number">8</span> <span class="comment">// Clean our EXECEPTION_REGISTRATION off stack</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而在实际情况中，有很多异常，并非一个异常处理函数就能处理所有情况，所以EXCEPTION_REGISTRATION是一个链表结构。操作系统沿着这个链表寻找，找到能够处理当前异常的异常回调函数。异常回调函数可以选择处理异常，也可以拒绝处理异常。这是一个用于演示异常回调函数拒绝处理异常的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==================================================</span></span><br><span class="line"><span class="comment">// MYSEH2 - Matt Pietrek 1997</span></span><br><span class="line"><span class="comment">// Microsoft Systems Journal, January 1997</span></span><br><span class="line"><span class="comment">// FILE: MYSEH2.CPP</span></span><br><span class="line"><span class="comment">// To compile: CL MYSEH2.CPP</span></span><br><span class="line"><span class="comment">//==================================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl</span><br><span class="line">_except_handler(</span><br><span class="line"><span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line"><span class="type">void</span> * EstablisherFrame,</span><br><span class="line"><span class="keyword">struct</span> _CONTEXT *ContextRecord,</span><br><span class="line"><span class="type">void</span> * DispatcherContext )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Home Grown handler: Exception Code: %08X Exception Flags %X&quot;</span>,</span><br><span class="line">        ExceptionRecord-&gt;ExceptionCode, ExceptionRecord-&gt;ExceptionFlags );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">1</span> )    <span class="built_in">printf</span>( <span class="string">&quot; EH_NONCONTINUABLE&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">2</span> )    <span class="built_in">printf</span>( <span class="string">&quot; EH_UNWINDING&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">4</span> )    <span class="built_in">printf</span>( <span class="string">&quot; EH_EXIT_UNWIND&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">8</span> )    <span class="built_in">printf</span>( <span class="string">&quot; EH_STACK_INVALID&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">0x10</span> ) <span class="built_in">printf</span>( <span class="string">&quot; EH_NESTED_CALL&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n&quot;</span> );</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Punt... We don&#x27;t want to handle this... Let somebody else handle it</span></span><br><span class="line">    <span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">HomeGrownFrame</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD handler = (DWORD)_except_handler;</span><br><span class="line">     </span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build EXCEPTION_REGISTRATION record:</span></span><br><span class="line">        push handler <span class="comment">// Address of handler function</span></span><br><span class="line">        push FS:[<span class="number">0</span>] <span class="comment">// Address of previous handler</span></span><br><span class="line">        mov FS:[<span class="number">0</span>],ESP <span class="comment">// Install new EXECEPTION_REGISTRATION</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    *(PDWORD)<span class="number">0</span> = <span class="number">0</span>; <span class="comment">// Write to address 0 to cause a fault</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;I should never get here!\n&quot;</span> );</span><br><span class="line">     </span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove our EXECEPTION_REGISTRATION record</span></span><br><span class="line">        mov eax,[ESP] <span class="comment">// Get pointer to previous record</span></span><br><span class="line">        mov FS:[<span class="number">0</span>], EAX <span class="comment">// Install previous record</span></span><br><span class="line">        add esp, <span class="number">8</span> <span class="comment">// Clean our EXECEPTION_REGISTRATION off stack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _try</span><br><span class="line">    &#123;</span><br><span class="line">        HomeGrownFrame(); </span><br><span class="line">    &#125;</span><br><span class="line">    _except( EXCEPTION_EXECUTE_HANDLER )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Caught the exception in main()\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_except_handler返回ExceptionContinueSearch告诉操作系统自己不处理异常，接下来是通过_except安装的异常回调函数，它打印<code>Caught the exception in main()</code>。我们在这里只是简单地忽略了这个异常。<br>首先记住：<strong>当一个异常回调函数拒绝处理某个异常时，它实际上也就拒绝了决定程序流程从何处恢复。只有处理某个异常的函数才能决定程序流从何处恢复。</strong>由于_except_handler并不处理异常，所以出错代码后的printf永远不会执行。</p>
<h2 id="展开-unwind"><a href="#展开-unwind" class="headerlink" title="展开(unwind)"></a>展开(unwind)</h2><p>如果运行这个程序，会发现输出有些奇怪。看起来_except_handler调用了两次，这是为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Home Grown handler: Exception Code: C0000005 Exception Flags 0</span><br><span class="line">Home Grown handler: Exception Code: C0000027 Exception Flags 2 EH_UNWINDING</span><br><span class="line">Caught the Exception in main()</span><br></pre></td></tr></table></figure>

<p>两次异常标志不同，第二次的异常标志是2，而这是由于**展开(unwind)**。<br><strong>当一个异常处理回调函数拒绝处理某个异常时，它会被再一次调用。</strong><br><strong>当异常发生时，系统遍历EXCEPTION_REGISTRATION结构链表，直到它找到一个处理这个异常的处理程序。一旦找到，系统就再次遍历这个链表，直到处理这个异常的结点为止。在这第二次遍历中，系统将再次调用每个异常处理函数。关键的区别是，在第二次调用中，异常标志被设置为2。这个值被定义为EH_UNWINDING。</strong><br>为何要这样设置（即调用两次未处理异常的函数）呢？这是为了给这个函数最后一个清理的机会。一个绝好的例子是C++类的析构函数。当一个函数的异常处理程序拒绝处理某个异常时，通常执行流程并不会正常地从那个函数退出。现在，想像一个定义了一个C++类的实例作为局部变量的函数。C++规范规定析构函数必须被调用。这带EH_UNWINDING标志的第二次回调就给这个函数一个机会去做一些类似于调用析构函数和__finally块之类的清理工作。<br>在异常已经被处理完毕，并且所有前面的异常帧都已经被展开之后，流程从处理异常的那个回调函数决定的地方开始继续执行。一定要记住，仅仅把指令指针设置到所需的代码处就开始执行是不行的。流程恢复执行处的代码的堆栈指针和栈帧指针（在Intel CPU上是ESP和EBP）也必须被恢复成它们在处理这个异常的函数的栈帧上的值。因此，这个处理异常的回调函数必须负责把堆栈指针和栈帧指针恢复成它们在包含处理这个异常的SEH代码的函数的堆栈上的值。<br>通常，展开操作导致堆栈上处理异常的帧以下的堆栈区域上的所有内容都被移除了，就好像我们从来没有调用过这些函数一样。展开的另外一个效果就是 EXCEPTION_REGISTRATION结构链表上处理异常的那个结构之前的所有EXCEPTION_REGISTRATION结构都被移除了。这很好理解，因为这些EXCEPTION_REGISTRATION结构通常都被创建在堆栈上。在异常被处理后，堆栈指针和栈帧指针在内存中比那些从 EXCEPTION_REGISTRATION结构链表上移除的EXCEPTION_REGISTRATION结构高。<br>链表的最后一个节点是操作系统提供的默认异常处理函数，它总是会选择处理异常。这个函数是在用户代码执行前插入的。下为BaseProcessStart函数写的伪代码，它是Windows NT KERNEL32.DLL的一个内部例程。这个函数带一个参数——线程入口点函数的地址。BaseProcessStart运行在新进程的环境中，并且它调用这个进程的第一个线程的入口点函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BaseProcessStart(PVOID lpfnEntryPoint)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD retValue;</span><br><span class="line">    DWORD currentESP;</span><br><span class="line">    DWORD exceptionCode;</span><br><span class="line">    currentESP = ESP;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        NtSetInformationThread(GetCurrentThread(),</span><br><span class="line">            ThreadQuerySetWin32StartAddress,</span><br><span class="line">            &amp;lpfnEntryPoint,</span><br><span class="line">            <span class="keyword">sizeof</span>(lpfnEntryPoint));</span><br><span class="line">        retValue = lpfnEntryPoint();</span><br><span class="line">        ExitThread(retValue);</span><br><span class="line">    &#125;</span><br><span class="line">    __except (   <span class="comment">//过滤器表达式代码</span></span><br><span class="line">        exceptionCode = GetExceptionInformation(),</span><br><span class="line">        UnhandledExceptionFilter(GetExceptionInformation()))</span><br><span class="line">    &#123;</span><br><span class="line">        ESP = currentESP;</span><br><span class="line">        <span class="keyword">if</span> (!_BaseRunningInServerProcess) <span class="comment">// 普通进程</span></span><br><span class="line">            ExitProcess(exceptionCode);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 服务</span></span><br><span class="line">            ExitThread(exceptionCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里👴实际上已经有点迷糊了（<br>那展开的意思是_except_handler会被调用两次，那么自己写个正常插入的异常试试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LONG <span class="title function_">MyFilter1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LONG <span class="title function_">MyFilter2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* a;</span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	__try &#123;</span><br><span class="line">		__try &#123;</span><br><span class="line">			*a = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;try~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		__except (MyFilter1()) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;catch 1\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (MyFilter2()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;catch 2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">catch 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><del>然鹅并没有传说中的调用两次</del><br>马萨卡是因为编译器并8是像手写汇编那样插入_except_handler的🐎<br>8过我注意到原文作者用到的宏跟我常用的不一样，于是把EXCEPTION_CONTINUE_SEARCH改成ExceptionContinueSearch试试（</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">catch 1</span><br></pre></td></tr></table></figure>

<p>👴直接人傻了。。。问chatgpt它说这俩常量是一个意思……于是👴紧急加了一句<code>printf(&quot;ExceptionContinueSearch: %#x\nEXCEPTION_CONTINUE_SEARCH: %#x\nEXCEPTION_EXECUTE_HANDLER: %#x\n&quot;, ExceptionContinueSearch, EXCEPTION_CONTINUE_SEARCH, EXCEPTION_EXECUTE_HANDLER);</code>，结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExceptionContinueSearch: 0x1</span><br><span class="line">EXCEPTION_CONTINUE_SEARCH: 0</span><br><span class="line">EXCEPTION_EXECUTE_HANDLER: 0x1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>☁️：❓<br>☁️：怎么会是捏❓</p>
</blockquote>
<p>fine，本来的疑问没解决，结果多了一堆新的疑问………<br>算了，暂且放下这些问题继续往下看</p>
<h2 id="编译器层面的SEH"><a href="#编译器层面的SEH" class="headerlink" title="编译器层面的SEH"></a>编译器层面的SEH</h2><p>关于编译器级的SEH我已经在[第一篇关于SEH的学习笔记]中写过了(<a target="_blank" rel="noopener" href="https://www.yunzh1jun.com/2022/05/27/WindowsSEH/)%EF%BC%8C%E6%AD%A4%E5%A4%84%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E8%A6%81%E7%82%B9%E3%80%82">https://www.yunzh1jun.com/2022/05/27/WindowsSEH/)，此处总结几个要点。</a></p>
<h2 id="基于帧的异常处理程序模型"><a href="#基于帧的异常处理程序模型" class="headerlink" title="基于帧的异常处理程序模型"></a>基于帧的异常处理程序模型</h2><p>简单地说，在一个函数中，一个__try块中的所有代码就通过创建在这个函数的堆栈帧上的一个EXCEPTION_REGISTRATION结构来保护。在函数的入口处，这个新的EXCEPTION_REGISTRATION结构被放在异常处理程序链表的头部。在__try块结束后，相应的 EXCEPTION_REGISTRATION结构从这个链表的头部被移除。正如前面所说，异常处理程序链表的头部被保存在FS:[0]处。因此，如果你在调试器中单步跟踪时看到类似MOV DWORD PTR FS:[00000000],ESP或者MOV DWORD PTR FS:[00000000],ECX的指令时,就能非常确定这段代码正在进入或退出一个__try&#x2F;__except块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span> *<span class="title">prev</span>;</span>      <span class="comment">//ebp-0x10</span></span><br><span class="line"><span class="type">void</span>                           *handler;   <span class="comment">//ebp-0x0c 异常处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scopetable_entry</span>        *<span class="title">scopetable</span>;</span><span class="comment">//ebp-8 类型为 scopetable_entry 的数组</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SCOPETABLE</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">         DWORD previousTryLevel; <span class="comment">//定位前一个try块的索引值</span></span><br><span class="line">         DWORD lpfnFilter;       <span class="comment">//当前try块的过滤函数</span></span><br><span class="line">         DWORD lpfnHandler;      <span class="comment">//当前try块的终止函数</span></span><br><span class="line">        &#125;SCOPETABLE, *PSCOPETABLE;</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span>                            trylevel;   <span class="comment">//ebp-4 数组下标，用来索引 scopetable 中的数组成员</span></span><br><span class="line"><span class="type">int</span>                            _ebp;       <span class="comment">//ebp 包含该 _EXCEPTION_REGISTRATION 结构体创建之前的栈帧指针</span></span><br><span class="line">    PEXCEPTION_POINTERS xpointers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个EXCEPTION_REGISTRATION结构的handler域都指向了同一个函数，这个函数调用了我们的异常过滤器。原文中说这个函数是__except_handler3，实际上现在自己编译一个程序的话会发现已经是__except_handler4🌶️（</p>
<p>以下是chatgpt关于这两个函数的说明：<br><code>__except_handler4</code> 和 <code>__except_handler3</code> 是 Microsoft 编译器提供的异常处理相关的内部函数。这些函数通常与 SEH（Structured Exception Handling）相关，用于处理 Windows 程序中的异常。</p>
<ul>
<li>区别：</li>
</ul>
<ol>
<li><p><strong>版本号：</strong></p>
<ul>
<li><code>__except_handler4</code> 是用于处理 SEH 异常的第四个版本的处理器。</li>
<li><code>__except_handler3</code> 是用于处理 SEH 异常的第三个版本的处理器。</li>
</ul>
</li>
<li><p><strong>支持的 Windows 版本：</strong></p>
<ul>
<li><code>__except_handler4</code> 是在 Windows Vista 和更高版本上引入的。</li>
<li><code>__except_handler3</code> 可能在 Windows XP 上使用。</li>
</ul>
</li>
</ol>
<ul>
<li>联系：</li>
</ul>
<p>这两个函数都是内部实现，通常不直接由开发人员调用。它们在异常处理的内部工作中发挥作用，例如在 C&#x2F;C++ 程序中的 <code>__try</code> 和 <code>__except</code> 块中。</p>
<p>最后，在使用SEH的任何函数中只创建一个EXCEPTION_REGISTRATION结构。换句话说，你可以在一个函数中使用多个__try&#x2F;__except块，但是在堆栈上只创建一个EXCEPTION_REGISTRATION结构。同样，你可以在一个函数中嵌套使用__try块，但Visual C++仍旧只是创建一个EXCEPTION_REGISTRATION结构。</p>
<h2 id="扩展的异常处理帧"><a href="#扩展的异常处理帧" class="headerlink" title="扩展的异常处理帧"></a>扩展的异常处理帧</h2><p><del>个人认为这里是最难理解的重点，可以多看几遍</del></p>
<p>_ebp域成为扩展的EXCEPTION_REGISTRATION结构的一部分并非偶然。它是通过PUSH EBP这条指令被包含进这个结构中的，而大多数函数开头都是这条指令（通常编译器并不为使用FPO优化的函数生成标准的堆栈帧，这样其第一条指令可能不是PUSH EBP。但是如果使用了SEH的话，那么无论你是否使用了FPO优化，编译器一定生成标准的堆栈帧）。这条指令可以使EXCEPTION_REGISTRATION结构中所有其它的域都可以用一个相对于栈帧指针（EBP）的负偏移来访问。例如 trylevel域在[EBP-04]处，scopetable指针在[EBP-08]处，等等。（也就是说，这个结构是从[EBP-10H]处开始的。）<br>紧跟着扩展的EXCEPTION_REGISTRATION结构下面，Visual C++压入了另外两个值。紧跟着（即[EBP-14H]处）的一个DWORD，是为一个指向EXCEPTION_POINTERS结构（一个标准的Win32 结构）的指针所保留的空间。<br>这里说两个特殊的编译器内联函数：</p>
<ul>
<li>GetExceptionInformation<br>  当调用这个函数时，Visual C++生成以下代码：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR [EBP-14]</span><br></pre></td></tr></table></figure></li>
<li>GetExceptionCode<br>与上一条相关，此函数只是返回GetExceptionInformation返回的数据结构（EXCEPTION_POINTERS）中的一个结构 （EXCEPTION_RECORD）中的一个域（ExceptionCode）的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, DWORD PTR[EBP - 14]    // 执行完毕，EAX指向EXCEPTION_POINTERS结构</span><br><span class="line">MOV EAX, DWORD PTR[EAX]         // 执行完毕，EAX指向EXCEPTION_RECORD结构</span><br><span class="line">MOV EAX, DWORD PTR[EAX]         // 执行完毕，EAX中是ExceptionCode的值</span><br></pre></td></tr></table></figure>

<p>现在回到扩展的EXCEPTION_REGISTRATION结构上来。在这个结构开始前的8个字节处（即[EBP-18H]处），Visual C++保留了一个DWORD来保存所有prolog代码执行完毕之后的堆栈指针（ESP）的值（实际生成的指令为MOV DWORD PTR [EBP-18H], ESP）。这个DWORD中保存的值是函数执行时ESP寄存器的正常值。<br>Visual C++为使用结构化异常处理的函数生成的标准异常堆栈帧如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EBP-00 _ebp</span><br><span class="line">EBP-04 trylevel</span><br><span class="line">EBP-08 scopetable数组指针</span><br><span class="line">EBP-0C handler函数地址</span><br><span class="line">EBP-10 指向前一个EXCEPTION_REGISTRATION结构</span><br><span class="line">EBP-14 GetExceptionInformation</span><br><span class="line">EBP-18 栈帧中的标准ESP</span><br></pre></td></tr></table></figure>
<p><strong>在操作系统看来，只存在组成原始EXCEPTION_REGISTRATION结构的两个域：即[EBP-10h]处的prev指针和[EBP-0Ch]处的handler函数指针。栈帧中的其它所有内容是针对于Visual C++的。</strong></p>
<p>真正实现编译器层面SEH的这个Visual C++运行时库例程——__except_handler3函数的伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __except_handler3(</span><br><span class="line">    <span class="keyword">struct</span> _EXCEPTION_RECORD * pExceptionRecord,</span><br><span class="line">    <span class="keyword">struct</span> EXCEPTION_REGISTRATION * pRegistrationFrame,</span><br><span class="line">    <span class="keyword">struct</span> _CONTEXT *pContextRecord,</span><br><span class="line">    <span class="type">void</span> * pDispatcherContext)</span><br><span class="line">&#123;</span><br><span class="line">    LONG filterFuncRet;</span><br><span class="line">    LONG trylevel;</span><br><span class="line">    EXCEPTION_POINTERS exceptPtrs;</span><br><span class="line">    PSCOPETABLE pScopeTable;</span><br><span class="line">    CLD <span class="comment">// 将方向标志复位（不测试任何条件！）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志</span></span><br><span class="line">    <span class="comment">// 表明这是第一次调用这个处理程序（也就是说，并非处于异常展开阶段）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(pExceptionRecord-&gt;ExceptionFlags</span><br><span class="line">        &amp; (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在堆栈上创建一个EXCEPTION_POINTERS结构</span></span><br><span class="line">        exceptPtrs.ExceptionRecord = pExceptionRecord;</span><br><span class="line">        exceptPtrs.ContextRecord = pContextRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把前面定义的EXCEPTION_POINTERS结构的地址放在比</span></span><br><span class="line">        <span class="comment">// establisher栈帧低4个字节的位置上。参考前面我讲</span></span><br><span class="line">        <span class="comment">// 的编译器为GetExceptionInformation生成的汇编代码</span></span><br><span class="line">        *(PDWORD)((PBYTE)pRegistrationFrame - <span class="number">4</span>) = &amp;exceptPtrs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取初始的“trylevel”值</span></span><br><span class="line">        trylevel = pRegistrationFrame-&gt;trylevel;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指向scopetable数组的指针 </span></span><br><span class="line">        scopeTable = pRegistrationFrame-&gt;scopetable;</span><br><span class="line"></span><br><span class="line">search_for_handler:</span><br><span class="line">        <span class="keyword">if</span> (pRegistrationFrame-&gt;trylevel != TRYLEVEL_NONE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pRegistrationFrame-&gt;scopetable[trylevel].lpfnFilter)</span><br><span class="line">            &#123;</span><br><span class="line">                PUSH EBP <span class="comment">// 保存这个栈帧指针</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// ！！！非常重要！！！切换回原来的EBP。正是这个操作才使得</span></span><br><span class="line">                <span class="comment">// 栈帧上的所有局部变量能够在异常发生后仍然保持它的值不变。</span></span><br><span class="line">                EBP = &amp;pRegistrationFrame-&gt;_ebp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用过滤器函数</span></span><br><span class="line">                filterFuncRet = scopetable[trylevel].lpfnFilter();</span><br><span class="line"></span><br><span class="line">                POP EBP <span class="comment">// 恢复异常处理程序的栈帧指针</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (filterFuncRet != EXCEPTION_CONTINUE_SEARCH)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (filterFuncRet &lt; <span class="number">0</span>) <span class="comment">// EXCEPTION_CONTINUE_EXECUTION</span></span><br><span class="line">                        <span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果能够执行到这里，说明返回值为EXCEPTION_EXECUTE_HANDLER</span></span><br><span class="line">                    scopetable = pRegistrationFrame-&gt;scopetable;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 让操作系统清理已经注册的栈帧，这会使本函数被递归调用</span></span><br><span class="line">                    __global_unwind2(pRegistrationFrame);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 一旦执行到这里，除最后一个栈帧外，所有的栈帧已经</span></span><br><span class="line">                    <span class="comment">// 被清理完毕，流程要从最后一个栈帧继续执行</span></span><br><span class="line">                    EBP = &amp;pRegistrationFrame-&gt;_ebp;</span><br><span class="line">                    __local_unwind2(pRegistrationFrame, trylevel);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// NLG = &quot;non-local-goto&quot; (setjmp/longjmp stuff)</span></span><br><span class="line">                    __NLG_Notify(<span class="number">1</span>); <span class="comment">// EAX = scopetable-&gt;lpfnHandler</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 把当前的trylevel设置成当找到一个异常处理程序时</span></span><br><span class="line">                    <span class="comment">// SCOPETABLE中当前正在被使用的那一个元素的内容</span></span><br><span class="line">                    pRegistrationFrame-&gt;trylevel = scopetable-&gt;previousTryLevel;</span><br><span class="line">                    <span class="comment">// 调用__except &#123;&#125;块，这个调用并不会返回</span></span><br><span class="line">                    pRegistrationFrame-&gt;scopetable[trylevel].lpfnHandler();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            scopeTable = pRegistrationFrame-&gt;scopetable;</span><br><span class="line">            trylevel = scopeTable-&gt;previousTryLevel;</span><br><span class="line">            <span class="keyword">goto</span> search_for_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// trylevel == TRYLEVEL_NONE</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 设置了EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUSH EBP <span class="comment">// 保存EBP</span></span><br><span class="line">        EBP = &amp;pRegistrationFrame-&gt;_ebp; <span class="comment">// 为调用__local_unwind2设置EBP</span></span><br><span class="line"></span><br><span class="line">        __local_unwind2(pRegistrationFrame, TRYLEVEL_NONE)</span><br><span class="line"></span><br><span class="line">        POP EBP <span class="comment">// 恢复EBP</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__except_handler3大体上可以由第一个if语句分为两部分。这是由于这个函数可以在两种情况下被调用，一次是正常调用，另一次是在展开阶段。其中大部分是在非展开阶段的回调。<br>__except_handler3一开始就在堆栈上创建了一个EXCEPTION_POINTERS结构，并用它的两个参数来对这个结构进行初始化。我在伪代码中把这个结构称为 exceptPrts，它的地址被放在[EBP-14h]处。你回忆一下前面我讲的编译器为GetExceptionInformation和 GetExceptionCode函数生成的汇编代码就会意识到，这实际上初始化了这两个函数使用的指针。<br>原文似乎并没有解释EXCEPTION_POINTERS到底是个什么东西，不过根据上下文可以推测出来是一个指向_EXCEPTION_RECORD的指针。在扩展的异常处理帧中，它指向当前的_EXCEPTION_RECORD。<br>接着，__except_handler3从EXCEPTION_REGISTRATION帧中获取当前的trylevel（在[EBP-04h]处）。trylevel变量实际是scopetable数组的索引，而正是这个数组才使得一个函数中的多个__try块和嵌套的__try块能够仅使用一个 EXCEPTION_REGISTRATION结构。每个scopetable元素结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SCOPETABLE</span>&#123;</span></span><br><span class="line">    DWORD previousTryLevel;<span class="comment">//定位前一个try块的索引值</span></span><br><span class="line">    DWORD lpfnFilter;      <span class="comment">//过滤器表达式代码的地址</span></span><br><span class="line">    DWORD lpfnHandler;     <span class="comment">//相应的__except块的地址</span></span><br><span class="line">&#125; SCOPETABLE, *PSCOPETABLE;</span><br></pre></td></tr></table></figure>

<p>总之一句话，它用于嵌套的__try块。这里的关键是函数中的每个__try块都有一个相应的SCOPETABLE结构。<br>当前的trylevel指定了要使用的scopetable数组的哪一个元素，最终也就是指定了过滤器表达式和__except块的地址。<br>previousTryLevel给出前一个__try块的索引，这是为了在嵌套的__try块中找到外层的__try块（前一个__try块实际上相当于外层的__try块）。这种机制将嵌套的__try块简化成一种数组的形式，让我们可以嵌套任意的__try块。<br>如果trylevel的值为0xFFFFFFFF（实际上就是-1，这个值在 EXSUP.INC中被定义为TRYLEVEL_NONE），标志着这个链表结束。<br>如果过滤器表达式返回EXCEPTION_EXECUTE_HANDLER， 这意味着异常应该由相应的__except块处理。它同时也意味着所有前面的EXCEPTION_REGISTRATION帧都应该从链表中移除，并且相应的__except块都应该被执行。第一个任务通过调用__global_unwind2来完成。跳过这中间的一些清理代码，流程离开__except_handler3转向__except块。令人奇怪的是，流程并不从__except块中返回，虽然是 __except_handler3使用CALL指令调用了它。__except_handler3是如何做到既通过CALL指令调用__except块而又不让执行流程返回呢？由于CALL指令要向堆栈中压入了一个返回地址，你可以想象这有可能破坏堆栈。如果你检查一下编译器为__except块生成的代码，你会发现它做的第一件事就是将EXCEPTION_REGISTRATION结构下面8个字节 处（即[EBP-18H]处）的一个DWORD值加载到ESP寄存器中（实际代码为<code>MOV ESP,DWORD PTR [EBP-18H]</code>）,这个值是在函数的prolog代码中被保存在这个位置的（实际代码为<code>MOV DWORD PTR [EBP-18H],ESP</code>）。<br>当前的trylevel值是如何被设置的呢？它实际上是由编译器隐含处理的。编译器修改当前EXCEPTION_REGISTRATION结构中的trylevel域的值（原文这里翻译得有点奇怪，实际上看这句代码<code>pRegistrationFrame-&gt;trylevel = scopetable-&gt;previousTryLevel;</code>就很容易能理解了）。如果你检查编译器为使用SEH的函数生成的汇编代码，就会在不同的地方都看到修改这个位于[EBP-04h]处的trylevel域的值的代码。</p>
<p>现在可以回答上面那个问题：为什么自己使用标准的__except块时不会由于展开而调用两次_except_handler？这是因为作者在之前的代码中重写了_except_handler函数，而标准的_except_handler3函数（实际上，这个函数依然会因为展开而被第二次调用）在展开阶段直接调用__local_unwind2来最后一次清理栈帧，而不是重新调用__except块。<br><del>当然了👴依旧并8能理解关于EXCEPTION_CONTINUE_SEARCH和ExceptionContinueSearch这两个变量MSVC到底在抽什么疯</del></p>
<h2 id="ShowSEHFrames程序"><a href="#ShowSEHFrames程序" class="headerlink" title="ShowSEHFrames程序"></a>ShowSEHFrames程序</h2><p>前面说得好像很乱 <del>而我已经在尽力捋清楚逻辑了</del> 当然了最好理解的办法当然还是自己写程序来应用这些理论，如果按照我们设想的那样运行，那就证明我们的理解是对的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=========================================================</span></span><br><span class="line"><span class="comment">// ShowSEHFrames - Matt Pietrek 1997</span></span><br><span class="line"><span class="comment">// Microsoft Systems Journal, February 1997</span></span><br><span class="line"><span class="comment">// FILE: ShowSEHFrames.CPP</span></span><br><span class="line"><span class="comment">// 使用命令行CL ShowSehFrames.CPP进行编译//=========================================================</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> hdrstop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 本程序仅适用于Visual C++，它使用的数据结构是特定于Visual C++的</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Visual C++ Required (Visual C++ specific information is displayed)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 结构定义</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统定义的基本异常帧</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EXCEPTION_REGISTRATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    EXCEPTION_REGISTRATION* prev;</span><br><span class="line">    FARPROC handler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visual C++扩展异常帧指向的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scopetable_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD previousTryLevel;</span><br><span class="line">    FARPROC lpfnFilter;</span><br><span class="line">    FARPROC lpfnHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visual C++使用的扩展异常帧</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VC_EXCEPTION_REGISTRATION</span> :</span> EXCEPTION_REGISTRATION</span><br><span class="line">&#123;</span><br><span class="line">    scopetable_entry * scopetable;</span><br><span class="line">    <span class="type">int</span> trylevel;</span><br><span class="line">    <span class="type">int</span> _ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 原型声明</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __except_handler3是Visual C++运行时库函数，我们想打印出它的地址</span></span><br><span class="line"><span class="comment">// 但是它的原型并没有出现在任何头文件中，所以我们需要自己声明它。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> _except_handler3(PEXCEPTION_RECORD,</span><br><span class="line">    EXCEPTION_REGISTRATION *,</span><br><span class="line">    PCONTEXT,</span><br><span class="line">    PEXCEPTION_RECORD);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 代码</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个异常帧及其相应的scopetable的信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSEHFrame</span><span class="params">(VC_EXCEPTION_REGISTRATION * pVCExcRec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame: %08X Handler: %08X Prev: %08X Scopetable: %08X\n&quot;</span>,</span><br><span class="line">        pVCExcRec, pVCExcRec-&gt;handler, pVCExcRec-&gt;prev,</span><br><span class="line">        pVCExcRec-&gt;scopetable);</span><br><span class="line">    scopetable_entry * pScopeTableEntry = pVCExcRec-&gt;scopetable;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt;= pVCExcRec-&gt;trylevel; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; scopetable[%u] PrevTryLevel: %08X &quot;</span></span><br><span class="line">            <span class="string">&quot;filter: %08X __except: %08X\n&quot;</span>, i,</span><br><span class="line">            pScopeTableEntry-&gt;previousTryLevel,</span><br><span class="line">            pScopeTableEntry-&gt;lpfnFilter,</span><br><span class="line">            pScopeTableEntry-&gt;lpfnHandler);</span><br><span class="line">        pScopeTableEntry++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历异常帧的链表，按顺序显示它们的信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WalkSEHFrames</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    VC_EXCEPTION_REGISTRATION * pVCExcRec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出__except_handler3函数的位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_except_handler3 is at address: %08X\n&quot;</span>, _except_handler3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从FS:[0]处获取指向链表头的指针</span></span><br><span class="line">    __asm mov eax, FS:[<span class="number">0</span>]</span><br><span class="line">    __asm mov[pVCExcRec], EAX</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历异常帧的链表。0xFFFFFFFF标志着链表的结尾</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0xFFFFFFFF</span> != (<span class="type">unsigned</span>)pVCExcRec)</span><br><span class="line">    &#123;</span><br><span class="line">        ShowSEHFrame(pVCExcRec);</span><br><span class="line">        pVCExcRec = (VC_EXCEPTION_REGISTRATION *)(pVCExcRec-&gt;prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Function1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 嵌套3层__try块以便强制为scopetable数组产生3个元素</span></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">            __try</span><br><span class="line">            &#123;</span><br><span class="line">                WalkSEHFrames(); <span class="comment">// 现在显示所有的异常帧的信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            __except (EXCEPTION_CONTINUE_SEARCH)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        __except (EXCEPTION_CONTINUE_SEARCH)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_CONTINUE_SEARCH)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个__try块（并不嵌套），这导致为scopetable数组生成两个元素</span></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">0x1234</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_CONTINUE_SEARCH)</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">0x4321</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        Function1(); <span class="comment">// 调用一个设置更多异常帧的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 应该永远不会执行到这里，因为我们并没有打算产生任何异常</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught Exception in main\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><img src="/./img/code/other/SEH1.jpg"></p>
<p>你可能想知道为什么明明ShowSEHFrames程序只有两个函数使用SEH，但是却有三个异常处理帧使用__except_handler3作为它们的异常回调函数。实际上第三个帧来自Visual C++运行时库。Visual C++运行时库源代码中的CRT0.C文件清楚地表明了对main或WinMain的调用也被一个__try&#x2F;__except块封装着。这个__try 块的过滤器表达式代码可以在WINXFLTR.C文件中找到。<br>回到ShowSEHFrames程序，注意到最后一个帧的异常处理程序的地址是77F3AB6C，这与其它三个不同。仔细观察一下，你会发现这个地址在 KERNEL32.DLL中。这个特别的帧就是由KERNEL32.DLL中的BaseProcessStart函数安装的，这在前面我已经说过。</p>
<p>现在对这个代码的结果分析一下，也算是一个简单的总结：每个函数中使用__try&#x2F;__except块，就会在异常链表中增加一个结点。<br>异常链表头（由BaseProcessStart函数安装），这是最后一个栈帧，此后对main函数的调用也由__try&#x2F;__except块封装，这是倒数第二个栈帧。然后是main函数中的栈帧：2个__try块生成了2个scopetable，由于__try块并没有嵌套，所以PrevTryLevel的值都为0xffffffff，表示当前__try块没有前一个__try块（即没有嵌套），这是第2个栈帧。最后是第一个栈帧，即Function1中的栈帧，由于__try块嵌套了3次，所以PrevTryLevel的值都代表嵌套的前一个__try块。<br><del>感觉这个可以出一道有意思的题 看我到时候给带🔥整个活</del></p>
<p>下面基本都是ctrl c + ctrl v了，直接看原文就🆗（</p>
<h2 id="except-handler的展开-Unwinding"><a href="#except-handler的展开-Unwinding" class="headerlink" title="__except_handler的展开(Unwinding)"></a>__except_handler的展开(Unwinding)</h2><p>正如你在Visual C++的__except_handler3函数中看到的那样，展开是由__global_unwind2这个运行时库（RTL）函数来完成的。这个函数只是对RtlUnwind这个未公开的API进行了非常简单的封装。（现在这个API已经被公开了，但给出的信息极其简单，详细信息可以参考最新的Platform SDK文档。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__global_unwind2(<span class="type">void</span> * pRegistFrame)</span><br><span class="line">&#123;</span><br><span class="line">    _RtlUnwind( pRegistFrame, &amp;__ret_label, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    __ret_label:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然从技术上讲RtlUnwind是一个KERNEL32函数，但它只是转发到了NTDLL.DLL中的同名函数上。图12是此函数的伪代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _RtlUnwind(</span><br><span class="line">    PEXCEPTION_REGISTRATION pRegistrationFrame,</span><br><span class="line">    PVOID returnAddr, <span class="comment">// 并未使用！（至少是在i386机器上）</span></span><br><span class="line">    PEXCEPTION_RECORD pExcptRec,</span><br><span class="line">    DWORD _eax_value)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD stackUserBase;</span><br><span class="line">    DWORD stackUserTop;</span><br><span class="line">    PEXCEPTION_RECORD pExcptRec;</span><br><span class="line">    EXCEPTION_RECORD exceptRec;</span><br><span class="line">    CONTEXT context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从FS:[4]和FS:[8]处获取堆栈的界限</span></span><br><span class="line">    RtlpGetStackLimits(&amp;stackUserBase, &amp;stackUserTop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pExcptRec) <span class="comment">// 正常情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        pExcptRec = &amp;excptRec;</span><br><span class="line">        pExcptRec-&gt;ExceptionFlags = <span class="number">0</span>;</span><br><span class="line">        pExcptRec-&gt;ExceptionCode = STATUS_UNWIND;</span><br><span class="line">        pExcptRec-&gt;ExceptionRecord = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取返回地址</span></span><br><span class="line">        pExcptRec-&gt;ExceptionAddress = RtlpGetReturnAddress();</span><br><span class="line">        pExcptRec-&gt;ExceptionInformation[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pRegistrationFrame)</span><br><span class="line">        pExcptRec-&gt;ExceptionFlags |= EXCEPTION_UNWINDING;</span><br><span class="line">    <span class="keyword">else</span>             <span class="comment">// 这两个标志合起来被定义为EXCEPTION_UNWIND_CONTEXT</span></span><br><span class="line">        pExcptRec-&gt;ExceptionFlags |= (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND);</span><br><span class="line"></span><br><span class="line">    context.ContextFlags = (CONTEXT_i486 | CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS);</span><br><span class="line"></span><br><span class="line">    RtlpCaptureContext(&amp;context);</span><br><span class="line"></span><br><span class="line">    context.Esp += <span class="number">0x10</span>;</span><br><span class="line">    context.Eax = _eax_value;</span><br><span class="line"></span><br><span class="line">    PEXCEPTION_REGISTRATION pExcptRegHead;</span><br><span class="line"></span><br><span class="line">    pExcptRegHead = RtlpGetRegistrationHead(); <span class="comment">// 返回FS:[0]的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始遍历EXCEPTION_REGISTRATION结构链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != pExcptRegHead)</span><br><span class="line">    &#123;</span><br><span class="line">        EXCEPTION_RECORD excptRec2;</span><br><span class="line">        <span class="keyword">if</span> (pExcptRegHead == pRegistrationFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            NtContinue(&amp;context, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果存在某个异常帧在堆栈上的位置比异常链表的头部还低</span></span><br><span class="line">            <span class="comment">// 说明一定出现了错误</span></span><br><span class="line">            <span class="keyword">if</span> (pRegistrationFrame &amp;&amp; (pRegistrationFrame &lt;= pExcptRegHead))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 生成一个异常</span></span><br><span class="line">                excptRec2.ExceptionRecord = pExcptRec;</span><br><span class="line">                excptRec2.NumberParameters = <span class="number">0</span>;</span><br><span class="line">                excptRec2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;</span><br><span class="line">                excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;</span><br><span class="line"></span><br><span class="line">                RtlRaiseException(&amp;exceptRec2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PVOID pStack = pExcptRegHead + <span class="number">8</span>; <span class="comment">// 8 = sizeof(EXCEPTION_REGISTRATION)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保pExcptRegHead在堆栈范围内，并且是4的倍数</span></span><br><span class="line">        <span class="keyword">if</span> ((stackUserBase &lt;= pExcptRegHead)</span><br><span class="line">            &amp;&amp; (stackUserTop &gt;= pStack)</span><br><span class="line">            &amp;&amp; (<span class="number">0</span> == (pExcptRegHead &amp; <span class="number">3</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD pNewRegistHead;</span><br><span class="line">            DWORD retValue;</span><br><span class="line"></span><br><span class="line">            retValue = RtlpExecutehandlerForUnwind(pExcptRec, pExcptRegHead, &amp;context,</span><br><span class="line">                &amp;pNewRegistHead, pExceptRegHead-&gt;handler);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retValue != DISPOSITION_CONTINUE_SEARCH)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (retValue != DISPOSITION_COLLIDED_UNWIND)</span><br><span class="line">                &#123;</span><br><span class="line">                    excptRec2.ExceptionRecord = pExcptRec;</span><br><span class="line">                    excptRec2.NumberParameters = <span class="number">0</span>;</span><br><span class="line">                    excptRec2.ExceptionCode = STATUS_INVALID_DISPOSITION;</span><br><span class="line">                    excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;</span><br><span class="line"></span><br><span class="line">                    RtlRaiseException(&amp;excptRec2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pExcptRegHead = pNewRegistHead;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PEXCEPTION_REGISTRATION pCurrExcptReg = pExcptRegHead;</span><br><span class="line">            pExcptRegHead = pExcptRegHead-&gt;prev;</span><br><span class="line"></span><br><span class="line">            RtlpUnlinkHandler(pCurrExcptReg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 堆栈已经被破坏！生成一个异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            excptRec2.ExceptionRecord = pExcptRec;</span><br><span class="line">            excptRec2.NumberParameters = <span class="number">0</span>;</span><br><span class="line">            excptRec2.ExceptionCode = STATUS_BAD_STACK;</span><br><span class="line">            excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;</span><br><span class="line"></span><br><span class="line">            RtlRaiseException(&amp;excptRec2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果执行到这里，说明已经到了EXCEPTION_REGISTRATION</span></span><br><span class="line">    <span class="comment">// 结构链表的末尾，正常情况下不应该发生这种情况。</span></span><br><span class="line">    <span class="comment">//（因为正常情况下异常应该被处理，这样就不会到链表末尾）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == pRegistrationFrame)</span><br><span class="line">        NtContinue(&amp;context, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        NtRaiseException(pExcptRec, &amp;context, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RtlUnwind函数的伪代码到这里就结束了，以下是它调用的几个函数的伪代码：</span></span><br><span class="line"></span><br><span class="line">PEXCEPTION_REGISTRATION <span class="title function_">RtlpGetRegistrationHead</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FS:[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">RtlpUnlinkHandler(PEXCEPTION_REGISTRATION pRegistrationFrame)</span><br><span class="line">&#123;</span><br><span class="line">    FS:[<span class="number">0</span>] = pRegistrationFrame-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RtlpCaptureContext</span><span class="params">(CONTEXT * pContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    pContext-&gt;Eax = <span class="number">0</span>;</span><br><span class="line">    pContext-&gt;Ecx = <span class="number">0</span>;</span><br><span class="line">    pContext-&gt;Edx = <span class="number">0</span>;</span><br><span class="line">    pContext-&gt;Ebx = <span class="number">0</span>;</span><br><span class="line">    pContext-&gt;Esi = <span class="number">0</span>;</span><br><span class="line">    pContext-&gt;Edi = <span class="number">0</span>;</span><br><span class="line">    pContext-&gt;SegCs = CS;</span><br><span class="line">    pContext-&gt;SegDs = DS;</span><br><span class="line">    pContext-&gt;SegEs = ES;</span><br><span class="line">    pContext-&gt;SegFs = FS;</span><br><span class="line">    pContext-&gt;SegGs = GS;</span><br><span class="line">    pContext-&gt;SegSs = SS;</span><br><span class="line">    pContext-&gt;EFlags = flags; <span class="comment">// 它对应的汇编代码为__asm&#123; PUSHFD / pop [xxxxxxxx] &#125;</span></span><br><span class="line">    pContext-&gt;Eip = 此函数的调用者的调用者的返回地址     <span class="comment">// 读者看一下这个函数的</span></span><br><span class="line">    pContext-&gt;Ebp = 此函数的调用者的调用者的EBP         <span class="comment">// 汇编代码就会清楚这一点</span></span><br><span class="line">    pContext-&gt;Esp = pContext-&gt;Ebp + <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然RtlUnwind函数的规模看起来很大，但是如果你按一定方法把它分开，其实并不难理解。它首先从FS:[4]和FS:[8]处获取当前线程堆栈的界限。它们对于后面要进行的合法性检查非常重要，以确保所有将要被展开的异常帧都在堆栈范围内。<br>RtlUnwind接着在堆栈上创建了一个空的EXCEPTION_RECORD结构并把STATUS_UNWIND赋给它的ExceptionCode域，同时把 EXCEPTION_UNWINDING标志赋给它的ExceptionFlags域。指向这个结构的指针作为其中一个参数被传递给每个异常回调函数。然后，这个函数调用RtlCaptureContext函数来创建一个空的CONTEXT结构，这个结构也变成了在展开阶段调用每个异常回调函数时传递给它们的一个参数。<br>RtlUnwind函数的其余部分遍历EXCEPTION_REGISTRATION结构链表。对于其中的每个帧，它都调用 RtlpExecuteHandlerForUnwind函数，后面我会讲到这个函数。正是这个函数带EXCEPTION_UNWINDING标志调用了异常处理回调函数。每次回调之后，它调用RtlpUnlinkHandler移除相应的异常帧。<br>RtlUnwind函数的第一个参数是一个帧的地址，当它遍历到这个帧时就停止展开异常帧。上面所说的这些代码之间还有一些安全性检查代码，它们用来确保不出问题。如果出现任何问题，RtlUnwind就引发一个异常，指示出了什么问题，并且这个异常带有EXCEPTION_NONCONTINUABLE标志。当一个进程被设置了这个标志时，它就不允许再运行，必须终止。</p>
<h2 id="未处理异常"><a href="#未处理异常" class="headerlink" title="未处理异常"></a>未处理异常</h2><p>UnhandledExceptionFilter，即KERNEL32中进行默认异常处理的过滤器表达式，前面BaseProcessStart函数的伪代码已经表明了这一点。<br>下为为UnhandledExceptionFilter函数写的伪代码。这个API有点奇怪（至少在我看来是这样）。如果异常的类型是 EXCEPTION_ACCESS_VIOLATION，它就调用_BasepCheckForReadOnlyResource。虽然我没有提供这个函数的伪代码，但可以简要描述一下。如果是因为要对EXE或DLL的资源节（.rsrc）进行写操作而导致的异常，_BasepCurrentTopLevelFilter就改变出错页面正常的只读属性，以便允许进行写操作。如果是这种特殊的情况，UnhandledExceptionFilter返回EXCEPTION_CONTINUE_EXECUTION，使系统重新执行出错指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">UnhandledExceptionFilter(STRUCT _EXCEPTION_POINTERS *pExceptionPtrs)</span><br><span class="line">&#123;</span><br><span class="line">    PEXCEPTION_RECORD pExcptRec;</span><br><span class="line">    DWORD currentESP;</span><br><span class="line">    DWORD retValue;</span><br><span class="line">    DWORD DEBUGPORT;</span><br><span class="line">    DWORD dwTemp2;</span><br><span class="line">    DWORD dwUseJustInTimeDebugger;</span><br><span class="line">    CHAR szDbgCmdFmt[<span class="number">256</span>];      <span class="comment">// 从AeDebug这个注册表键值返回的字符串</span></span><br><span class="line">    CHAR szDbgCmdLine[<span class="number">256</span>];     <span class="comment">// 实际的调试器命令行参数（已填入进程ID和事件ID）</span></span><br><span class="line">    STARTUPINFO startupinfo;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    HARDERR_STRUCT harderr;     <span class="comment">// ???</span></span><br><span class="line">    BOOL fAeDebugAuto;</span><br><span class="line">    TIB * pTib;                 <span class="comment">// 线程信息块</span></span><br><span class="line"></span><br><span class="line">    pExcptRec = pExceptionPtrs-&gt;ExceptionRecord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pExcptRec-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION)</span><br><span class="line">        &amp;&amp; (pExcptRec-&gt;ExceptionInformation[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        retValue = BasepCheckForReadOnlyResource(pExcptRec-&gt;ExceptionInformation[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (EXCEPTION_CONTINUE_EXECUTION == retValue)</span><br><span class="line">            <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看这个进程是否运行于调试器下</span></span><br><span class="line">    retValue = NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &amp;debugPort, <span class="keyword">sizeof</span>(debugPort), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((retValue &gt;= <span class="number">0</span>) &amp;&amp; debugPort) <span class="comment">// 通知调试器</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户调用SetUnhandledExceptionFilter了吗？</span></span><br><span class="line">    <span class="comment">// 如果调用了，那现在就调用他安装的异常处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (_BasepCurrentTopLevelFilter)</span><br><span class="line">    &#123;</span><br><span class="line">        retValue = _BasepCurrentTopLevelFilter(pExceptionPtrs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (EXCEPTION_EXECUTE_HANDLER == retValue)</span><br><span class="line">            <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">        <span class="keyword">if</span> (EXCEPTION_CONTINUE_EXECUTION == retValue)</span><br><span class="line">            <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有返回值为EXCEPTION_CONTINUE_SEARCH时才会继续执行下去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用过SetErrorMode(SEM_NOGPFAULTERRORBOX)吗？</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (GetErrorMode() &amp; SEM_NOGPFAULTERRORBOX))</span><br><span class="line">    &#123;</span><br><span class="line">        harderr.elem0 = pExcptRec-&gt;ExceptionCode;</span><br><span class="line">        harderr.elem1 = pExcptRec-&gt;ExceptionAddress;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (EXCEPTION_IN_PAGE_ERROR == pExcptRec-&gt;ExceptionCode)</span><br><span class="line">            harderr.elem2 = pExcptRec-&gt;ExceptionInformation[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            harderr.elem2 = pExcptRec-&gt;ExceptionInformation[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        dwTemp2 = <span class="number">1</span>;</span><br><span class="line">        fAeDebugAuto = FALSE;</span><br><span class="line"></span><br><span class="line">        harderr.elem3 = pExcptRec-&gt;ExceptionInformation[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        pTib = FS:[<span class="number">18</span>h];</span><br><span class="line"></span><br><span class="line">        DWORD someVal = pTib-&gt;pProcess-&gt;<span class="number">0xC</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pTib-&gt;threadID != someVal)</span><br><span class="line">        &#123;</span><br><span class="line">            __try</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> szDbgCmdFmt[<span class="number">256</span>];</span><br><span class="line">                retValue = GetProfileStringA(<span class="string">&quot;AeDebug&quot;</span>, <span class="string">&quot;Debugger&quot;</span>, <span class="number">0</span>, szDbgCmdFmt, <span class="keyword">sizeof</span>(szDbgCmdFmt) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (retValue)</span><br><span class="line">                    dwTemp2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> szAuto[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">                retValue = GetProfileStringA(<span class="string">&quot;AeDebug&quot;</span>, <span class="string">&quot;Auto&quot;</span>, <span class="string">&quot;0&quot;</span>, szAuto, <span class="keyword">sizeof</span>(szAuto) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (retValue)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(szAuto, <span class="string">&quot;1&quot;</span>))</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">2</span> == dwTemp2)</span><br><span class="line">                            fAeDebugAuto = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">            &#123;</span><br><span class="line">                ESP = currentESP;</span><br><span class="line">                dwTemp2 = <span class="number">1</span>;</span><br><span class="line">                fAeDebugAuto = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FALSE == fAeDebugAuto)</span><br><span class="line">        &#123;</span><br><span class="line">            retValue = NtRaiseHardError(STATUS_UNHANDLED_EXCEPTION | <span class="number">0x10000000</span>, <span class="number">4</span>, <span class="number">0</span>, &amp;harderr, _BasepAlreadyHadHardError ? <span class="number">1</span> : dwTemp2, &amp;dwUseJustInTimeDebugger);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dwUseJustInTimeDebugger = <span class="number">3</span>;</span><br><span class="line">            retValue = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retValue &gt;= <span class="number">0</span> &amp;&amp; (dwUseJustInTimeDebugger == <span class="number">3</span>) &amp;&amp; (!_BasepAlreadyHadHardError) &amp;&amp; (!_BaseRunningInServerProcess))</span><br><span class="line">        &#123;</span><br><span class="line">            _BasepAlreadyHadHardError = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            SECURITY_ATTRIBUTES secAttr = &#123; <span class="keyword">sizeof</span>(secAttr), <span class="number">0</span>, TRUE &#125;;</span><br><span class="line"></span><br><span class="line">            HANDLE hEvent = CreateEventA(&amp;secAttr, TRUE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(&amp;startupinfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(startupinfo));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sprintf</span>(szDbgCmdLine, szDbgCmdFmt, GetCurrentProcessId(), hEvent);</span><br><span class="line"></span><br><span class="line">            startupinfo.cb = <span class="keyword">sizeof</span>(startupinfo);</span><br><span class="line">            startupinfo.lpDesktop = <span class="string">&quot;Winsta0\Default&quot;</span>;</span><br><span class="line"></span><br><span class="line">            CsrIdentifyAlertableThread();       <span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line">            retValue = CreateProcessA(</span><br><span class="line">                <span class="number">0</span>,              <span class="comment">// 应用程序名称</span></span><br><span class="line">                szDbgCmdLine,   <span class="comment">// 命令行</span></span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>,           <span class="comment">// 进程和线程安全属性</span></span><br><span class="line">                <span class="number">1</span>,              <span class="comment">// bInheritHandles</span></span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>,           <span class="comment">// 创建标志、环境</span></span><br><span class="line">                <span class="number">0</span>,              <span class="comment">// 当前目录</span></span><br><span class="line">                &amp;statupinfo,    <span class="comment">// STARTUPINFO</span></span><br><span class="line">                &amp;pi);           <span class="comment">// PROCESS_INFORMATION</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retValue &amp;&amp; hEvent)</span><br><span class="line">            &#123;</span><br><span class="line">                NtWaitForSingleObject(hEvent, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_BasepAlreadyHadHardError)</span><br><span class="line">            NtTerminateProcess(GetCurrentProcess(), pExcptRec-&gt;ExceptionCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPTOP_LEVEL_EXCEPTION_FILTER <span class="title function_">SetUnhandledExceptionFilter</span><span class="params">(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _BasepCurrentTopLevelFilter是KERNEL32.DLL中的一个全局变量</span></span><br><span class="line">    LPTOP_LEVEL_EXCEPTION_FILTER previous = _BasepCurrentTopLevelFilter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为新值</span></span><br><span class="line">    _BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> previous; <span class="comment">// 返回以前的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，UnhandledExceptionFilter先确定进程是否在调试器下，如果处于调试状态则唤醒调试器，告诉它被调试程序产生了一个异常。如果没有，UnhandledExceptionFilter接下来调用用户安装的未处理异常过滤器（如果存在的话）。通常情况下，用户并没有安装回调函数，但是用户可以调用 SetUnhandledExceptionFilter这个API来安装。上面我也提供了这个API的伪代码。这个函数只是简单地用用户安装的回调函数的地址来替换一个全局变量，并返回替换前的值。<br>有了初步的准备之后，UnhandledExceptionFilter就开始做它的主要工作：用一个令人血压骤升的应用程序错误对话框来通知你犯了低级的编程错误。 <del>（原文是“时髦的应用程序错误对话框”，但👴觉得现在的形容词更贴切一些）</del> UnhandledExceptionFilter调用NTDLL.DLL中的 NtRaiseHardError函数。正是这个函数产生了应用程序错误对话框。这个对话框等待你单击“确定”按钮来终止进程，或者单击“取消”按钮来调试它。<br>如果你单击“确定”，UnhandledExceptionFilter就返回EXCEPTION_EXECUTE_HANDLER。调用UnhandledExceptionFilter 的进程通常通过终止自身来作为响应（正像你在BaseProcessStart的伪代码中看到的那样）。这就产生了一个有趣的问题——大多数人都认为是系统终止了产生未处理异常的进程，而实际上更准确的说法应该是，系统进行了一些设置使得产生未处理异常的进程将自身终止掉了。<br>UnhandledExceptionFilter执行时真正有意思的部分是当你单击应用程序错误对话框中的“取消”按钮，此时系统将调试器附加（attach）到出错进程上。这段代码首先调用 CreateEvent来创建一个事件内核对象，调试器成功附加到出错进程之后会将此事件对象变成有信号状态。这个事件句柄以及出错进程的ID都被传到sprintf函数，由它将其格式化成一个命令行，用来启动调试器。一切就绪之后，UnhandledExceptionFilter就调用 CreateProcess来启动调试器。如果CreateProcess成功，它就调用NtWaitForSingleObject来等待前面创建的那个事件对象。此时这个调用被阻塞，直到调试器进程将此事件变成有信号状态，以表明它已经成功附加到出错进程上。 UnhandledExceptionFilter函数中还有一些其它的代码，我在这里只讲重要的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你已经走了这么远，不把整个过程讲完对你有点不公平。我已经讲了当异常发生时操作系统是如何调用用户定义的回调函数的。我也讲了这些回调的内部情况，以及编译器是如何使用它们来实现__try和__except的。我甚至还讲了当某个异常没有被处理时所发生的情况以及系统所做的扫尾工作。剩下的就只有异常回调过程最初是从哪里开始的这个问题了。好吧，让我们深入系统内部来看一下结构化异常处理的开始阶段吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">KiUserExceptionDispatcher(PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD retValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：如果异常被处理，那么RtlDispatchException函数就不会返回</span></span><br><span class="line">    <span class="keyword">if</span> (RtlDispatchException(pExceptRec, pContext))</span><br><span class="line">        retValue = NtContinue(pContext, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        retValue = NtRaiseException(pExceptRec, pContext, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    EXCEPTION_RECORD excptRec2;</span><br><span class="line">    excptRec2.ExceptionCode = retValue;</span><br><span class="line">    excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;</span><br><span class="line">    excptRec2.ExceptionRecord = pExcptRec;</span><br><span class="line">    excptRec2.NumberParameters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    RtlRaiseException(&amp;excptRec2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">RtlDispatchException</span><span class="params">(PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD stackUserBase;</span><br><span class="line">    DWORD stackUserTop;</span><br><span class="line">    PEXCEPTION_REGISTRATION pRegistrationFrame;</span><br><span class="line">    DWORD hLog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从FS:[4]和FS:[8]处获取堆栈的界限</span></span><br><span class="line">    RtlpGetStackLimits(&amp;stackUserBase, &amp;stackUserTop);</span><br><span class="line"></span><br><span class="line">    pRegistrationFrame = RtlpGetRegistrationHead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != pRegistrationFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        PVOID justPastRegistrationFrame = &amp;pRegistrationFrame + <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (stackUserBase &gt; justPastRegistrationFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EH_STACK_INVALID;</span><br><span class="line">            <span class="keyword">return</span> DISPOSITION_DISMISS; <span class="comment">// 0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stackUsertop &lt; justPastRegistrationFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EH_STACK_INVALID;</span><br><span class="line">            <span class="keyword">return</span> DISPOSITION_DISMISS; <span class="comment">// 0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRegistrationFrame &amp; <span class="number">3</span>) <span class="comment">// 确保堆栈按DWORD对齐</span></span><br><span class="line">        &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EH_STACK_INVALID;</span><br><span class="line">            <span class="keyword">return</span> DISPOSITION_DISMISS; <span class="comment">// 0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (someProcessFlag)</span><br><span class="line">        &#123;</span><br><span class="line">            hLog = RtlpLogExceptionHandler(pExcptRec, pContext, <span class="number">0</span>, pRegistrationFrame, <span class="number">0x10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DWORD retValue, dispatcherContext;</span><br><span class="line"></span><br><span class="line">        retValue = RtlpExecuteHandlerForException(pExcptRec, pRegistrationFrame,</span><br><span class="line">            pContext, &amp;dispatcherContext,</span><br><span class="line">            pRegistrationFrame-&gt;handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (someProcessFlag)</span><br><span class="line">            RtlpLogLastExceptionDisposition(hLog, retValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == pRegistrationFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags &amp;= ~EH_NESTED_CALL; <span class="comment">// 关闭标志</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EXCEPTION_RECORD excptRec2;</span><br><span class="line"></span><br><span class="line">        DWORD yetAnotherValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DISPOSITION_DISMISS == retValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pExcptRec-&gt;ExceptionFlags &amp; EH_NONCONTINUABLE)</span><br><span class="line">            &#123;</span><br><span class="line">                excptRec2.ExceptionRecord = pExcptRec;</span><br><span class="line">                excptRec2.ExceptionNumber = STATUS_NONCONTINUABLE_EXCEPTION;</span><br><span class="line">                excptRec2.ExceptionFlags = EH_NONCONTINUABLE;</span><br><span class="line">                excptRec2.NumberParameters = <span class="number">0</span>;</span><br><span class="line">                RtlRaiseException(&amp;excptRec2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> DISPOSITION_CONTINUE_SEARCH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DISPOSITION_CONTINUE_SEARCH == retValue)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DISPOSITION_NESTED_EXCEPTION == retValue)</span><br><span class="line">        &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EH_EXIT_UNWIND;</span><br><span class="line">            <span class="keyword">if</span> (dispatcherContext &gt; yetAnotherValue)</span><br><span class="line">                yetAnotherValue = dispatcherContext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// DISPOSITION_COLLIDED_UNWIND</span></span><br><span class="line">        &#123;</span><br><span class="line">            excptRec2.ExceptionRecord = pExcptRec;</span><br><span class="line">            excptRec2.ExceptionNumber = STATUS_INVALID_DISPOSITION;</span><br><span class="line">            excptRec2.ExceptionFlags = EH_NONCONTINUABLE;</span><br><span class="line">            excptRec2.NumberParameters = <span class="number">0</span>;</span><br><span class="line">            RtlRaiseException(&amp;excptRec2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pRegistrationFrame = pRegistrationFrame-&gt;prev; <span class="comment">// 转到前一个帧</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DISPOSITION_DISMISS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_RtlpExecuteHandlerForException: <span class="comment">// 处理异常（第一次）</span></span><br><span class="line">MOV EDX, XXXXXXXX</span><br><span class="line">JMP ExecuteHandler</span><br><span class="line"></span><br><span class="line">RtlpExecutehandlerForUnwind : <span class="comment">// 处理展开（第二次）</span></span><br><span class="line">MOV EDX, XXXXXXXX</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ExecuteHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    PEXCEPTION_RECORD pExcptRec,</span></span><br><span class="line"><span class="params">    PEXCEPTION_REGISTRATION pExcptReg,</span></span><br><span class="line"><span class="params">    CONTEXT * pContext,</span></span><br><span class="line"><span class="params">    PVOID pDispatcherContext,</span></span><br><span class="line"><span class="params">    FARPROC handler)</span> <span class="comment">// 实际上是指向_except_handler()的指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 安装一个EXCEPTION_REGISTRATION帧，EDX指向相应的handler代码</span></span><br><span class="line">    PUSH EDX</span><br><span class="line">    PUSH FS : [<span class="number">0</span>]</span><br><span class="line">    MOV FS : [<span class="number">0</span>], ESP</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用异常处理回调函数</span></span><br><span class="line">    EAX = handler(pExcptRec, pExcptReg, pContext, pDispatcherContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除EXCEPTION_REGISTRATION帧</span></span><br><span class="line">    MOV ESP, DWORD PTR FS : [<span class="number">00000000</span>]</span><br><span class="line">    POP DWORD PTR FS : [<span class="number">00000000</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_RtlpExecuteHandlerForException使用的异常处理程序：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果设置了展开标志，返回DISPOSITION_CONTINUE_SEARCH</span></span><br><span class="line">    <span class="comment">// 否则，给pDispatcherContext赋值并返回DISPOSITION_NESTED_EXCEPTION</span></span><br><span class="line">    <span class="keyword">return</span> pExcptRec-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT </span><br><span class="line">    ? DISPOSITION_CONTINUE_SEARC </span><br><span class="line">    : (*pDispatcherContext = pRegistrationFrame-&gt;scopetable,</span><br><span class="line">    DISPOSITION_NESTED_EXCEPTION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_RtlpExecuteHandlerForUnwind使用的异常处理程序：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果设置了展开标志，返回DISPOSITION_CONTINUE_SEARCH</span></span><br><span class="line">    <span class="comment">// 否则，给pDispatcherContext赋值并返回DISPOSITION_COLLIDED_UNWIND</span></span><br><span class="line">    <span class="keyword">return</span> pExcptRec-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT </span><br><span class="line">    ? DISPOSITION_CONTINUE_SEARCH </span><br><span class="line">    : (*pDispatcherContext = pRegistrationFrame-&gt;scopetable,</span><br><span class="line">    DISPOSITION_COLLIDED_UNWIND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KiUserExceptionDispatcher的核心是对RtlDispatchException的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。<br>现在把目光对准RtlDispatchException函数的代码，这就是我通篇提到的遍历异常帧的代码。这个函数获取一个指向EXCEPTION_REGISTRATION结构链表的指针，然后遍历此链表以寻找一个异常处理程序。由于堆栈可能已经被破坏了，所以这个例程非常谨慎。在调用每个EXCEPTION_REGISTRATION结构中指定的异常处理程序之前，它确保这个结构是按DWORD对齐的，并且是在线程的堆栈之中，同时在堆栈中比前一个EXCEPTION_REGISTRATION结构高。<br>RtlDispatchException并不直接调用EXCEPTION_REGISTRATION结构中指定的异常处理程序。相反，它调用 RtlpExecuteHandlerForException来完成这个工作。根据RtlpExecuteHandlerForException的执行情况，RtlDispatchException或者继续遍历异常帧，或者引发另一个异常。这第二次的异常表明异常处理程序内部出现了错误，这样就不能继续执行下去了。<br>RtlpExecuteHandlerForException的代码与RtlpExecuteHandlerForUnwind的代码极其相似。你可能会回忆起来在前面讨论展开时我提到过它。这两个“函数”都只是简单地给EDX寄存器加载一个不同的值然后就调用ExecuteHandler函数。也就是说，RtlpExecuteHandlerForException和RtlpExecuteHandlerForUnwind都是ExecuteHanlder这个公共函数的前端。<br>ExecuteHandler查找EXCEPTION_REGISTRATION结构的handler域的值并调用它。令人奇怪的是，对异常处理回调函数的调用本身也被一个结构化异常处 理程序封装着。在SEH自身中使用SEH看起来有点奇怪，但你思索一会儿就会理解其中的含义。如果在异常回调过程中引发了另外一个异常，操作系统需要知道这个情况。根据异常发生在最初的回调阶段还是展开回调阶段，ExecuteHandler或者返回DISPOSITION_NESTED_EXCEPTION，或者返回DISPOSITION_COLLIDED_UNWIND。这两者都是“红色警报！现在把一切都关掉！”类型的代码。<br>如果你像我一样，那不仅理解所有与SEH有关的函数非常困难，而且记住它们之间的调用关系也非常困难。为了帮助我自己记忆，我画了一个调用关系图（图15）。<br>现在要问：在调用ExecuteHandler之前设置EDX寄存器的值有什么用呢？这非常简单。如果ExecuteHandler在调用用户安装的异常处 理程序的过程中出现了什么错误，它就把EDX指向的代码作为原始的异常处理程序。它把EDX寄存器的值压入堆栈作为原始的 EXCEPTION_REGISTRATION结构的handler域。这基本上与我在MYSEH和MYSEH2中对原始的结构化异常处理的使用情况一 样。</p>
<p><img src="/./img/code/other/SEH2.jpg"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>系统层面的SEH就是围绕着简单的回调在打转。如果你理解了回调的本质，在此基础上分层理解，系统层面的结构化异常处理也不是那么难掌握。<br><del>SEH太有意思🌶️！</del><br>SEH系列完结撒花！</p>

    </div>

    <div class="about">
        <h1>关于本文</h1>
        <p>本文作者 云之君, 许可由 <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>

    
        
    
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/CTF" class="item">CTF</a>
                
                <a href="/Learn" class="item">Learn</a>
                
                <a href="/Diary" class="item">Diary</a>
                
                <a href="/friends" class="item">Friends</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/YunZh1Jun" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://space.bilibili.com/25320847" class="item">Bilibili</a>
                
                <a href="mailto:yunzh1jun@qq.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2023 云之君<br >驱动由 <a href="http://hexo.io/" target="_blank">Hexo</a></span>
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
    </body>
</html>