<!DOCTYPE html>
<html lang="zh-cn">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>Windows-SEH学习笔记 - 云之君&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/img/fav/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
    
<script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
 
  

  
<meta name="generator" content="Hexo 5.4.2"></head>
    <body data-color-scheme="auto">
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">云之君&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">主页</a>
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/CTF">CTF</a>
            
            
            
            <a class="nav-item" href="/Learn">Learn</a>
            
            
            
            <a class="nav-item" href="/Diary">Diary</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/YunZh1Jun" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            
            
            <span>May</span>
            
            
            
            
            
            
            
            
            <span>27,</span>
            <span>2022</span>
        </div>
        

        <h2 class="title">Windows-SEH学习笔记</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>初探Windows SEH（只是入门级</p>
<span id="more"></span>

<h4 id="一些闲话"><a href="#一些闲话" class="headerlink" title="一些闲话"></a>一些闲话</h4><p>其实SEH的概念之前已经接触过几次了，第一次是在瞎翻track和含树师傅博客的时候，看到21年的miniL有涉及到这个东西，<del>觉得还是含树师傅的方法（一个一个翻函数）最管用，所以就没太在意这个东西</del>。直到寒假做hgame的题被教育了，后来刷buu逆向的时候做到SCTF2019的creakme又被教育了一通，觉得还是得了解这个东西吧。<br>怎么说呢，做题毕竟只是做题，可能这道题可以嗯翻函数，另一个题可以嗯怼汇编，即使一点也不了解这个东西也能拿到flag。但是我感觉，不知道原理的话，对一些<del>比较屑的</del>题还是难免无从下手吧，而且明白一个东西之后用起来感觉会更顺手一些。<br>最初知道寻找SEH相关的一些调用地址是在《逆向工程核心原理》这本书上，然后自己拿题目瞎调了一通。但是调出来的东西，跟书上说的东西，不能说是毫不相干，只能说是八竿子打不着(x，只好去网上找各种博客康。看了很多篇之后慢慢感觉理解了一些，感觉里面还是有挺多很有意思的东西，然后又综合《逆向工程核心原理》和《加密与解密》， <del>再顺便完成复现题目的任务，</del> 自己写了一篇博客。</p>
<p>不过这篇文章只是一些比较简单的应用，而且只涉及了SEH，也只有静态分析的部分， <del>（因为我太菜了，OD还用不熟练，之后也许会写一篇动调的）</del> 对于VEH、UEH、VCH等异常处理还没有研究过，SEH栈展开之类的高级内容也许以后学了会再写一篇（逃</p>
<h4 id="本文面向的读者"><a href="#本文面向的读者" class="headerlink" title="本文面向的读者"></a>本文面向的读者</h4><ul>
<li>想要了解SEH的逆向er（不会读汇编也没关系，涉及到的知识和相关操作我会作简要说明）</li>
<li>吃瓜群众（因为我觉得会C语言应该就能看懂嘿嘿嘿）</li>
</ul>
<p>初次接触很多新的概念是会感觉陌生和难以理解，翻来覆去多看几遍，对照着题目练习，慢慢就能接受了。</p>
<h4 id="用到的示例题目"><a href="#用到的示例题目" class="headerlink" title="用到的示例题目"></a>用到的示例题目</h4><ul>
<li><a href="/code/chall/creakme2.exe">hgame_creakme2</a></li>
<li><a href="/code/chall/miniLre2.exe">miniL2021_0oooops</a></li>
<li><a target="_blank" rel="noopener" href="https://files.buuoj.cn/files/9bf1e6a1203a85e774ab9f158a11d428/attachment.exe">SCTF2019_creakme</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/0xE4s0n/creakme_sctf2019/blob/master/creakme/creakme.cpp">SCTF2019_creakme源码</a></li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnt">winnt.h文档</a><br><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-32222.htm">https://bbs.pediy.com/thread-32222.htm</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanrenxinxin/p/4631836.html">https://www.cnblogs.com/lanrenxinxin/p/4631836.html</a><br><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-206603.htm">https://bbs.pediy.com/thread-206603.htm</a><br>《逆向工程核心原理》第46~48章<br>《加密与解密》第8章</p>
<h2 id="SEH简要说明"><a href="#SEH简要说明" class="headerlink" title="SEH简要说明"></a>SEH简要说明</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>SEH是Windows提供的一种异常处理机制，在源代码中使用<code>__try</code>、<code>__except</code>、<code>__finally</code>关键字来实现。简而言之，就是当程序（<code>__try</code>块中的语句）发生异常，我们可以选择使用自己定义的函数来处理异常（在<code>__except</code>块中调用），而不是使用操作系统提供的异常（弹一个报错窗口然后退出程序）来处理。</p>
<h3 id="SEH与逆向"><a href="#SEH与逆向" class="headerlink" title="SEH与逆向"></a>SEH与逆向</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>异常处理对于逆向来说最大的问题就是 <strong><code>__except</code>块中的内容不会被IDA反编译出来</strong> ，可以据此隐藏核心代码。所以当解密过程很明确，但就是死活解出来一堆乱码，或者反编译出来的代码逻辑很迷的时候，就要考虑是不是用一些特殊的方法隐藏了核心代码……</p>
<p>具体而言，我寒假做hgame的时候被week2的fakeshell和creakme2折磨N久，一个是RC4，一个是xtea，都有很明确的解密流程，但解出来就是一堆乱码……我甚至尝试调试后把乱码数据写到栈上，然后用题目程序加密。结果当然是跟密文一样，所以某人直接自闭了……<br>后来看题解才知道，fakeshell是使用<code>__attribute((constructor)) </code>隐藏了一段代码逻辑，而creakme2是使用SEH隐藏了一段代码逻辑……<br><code>__attribute((constructor)) </code>是用于初始化的一段函数，在main函数之前执行，反编译结果在是在<code>_libc_start_main</code>中的<code>init</code>参数里。<br><del>所以现在养成习惯，看main函数之前先翻一下<code>init</code>段……</del></p>
<h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>进程在运行过程中发生异常时，操作系统会委托进程自身处理。如果进程自身有相关的异常处理（比如SEH），那么就由程序自身处理，否则OS启动默认的异常处理机制，终止程序，也就是上面说到的过程。<br>而当程序处于调试状态时，调试者拥有被调试者的所有权限（读写内存、寄存器等），所以 <strong>调试过程中的任何异常都要先交由调试者处理，而不会流转到正常的异常处理过程。</strong> 这样就增加了调试的难度。</p>
<p>调试遇到异常时，如果需要进入异常，一般的处理方法：</p>
<ul>
<li>手动找到<code>__except</code>块，修改EIP值指向正常的异常处理过程。<br>在OD中使用New Origin here(Ctrl+Gray *)改变程序运行路径。</li>
<li>在OD中使用shift+f7/f8/f9直接将异常抛还给被调试者</li>
</ul>
<p>如果无需进入异常，直接nop掉产生异常的代码即可，或者根据异常代码处理相应的内存和寄存器值也可以。</p>
<h2 id="SEH简要分析"><a href="#SEH简要分析" class="headerlink" title="SEH简要分析"></a>SEH简要分析</h2><h3 id="SEH具体实现"><a href="#SEH具体实现" class="headerlink" title="SEH具体实现"></a>SEH具体实现</h3><p>SEH异常处理程序的基本结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">        <span class="comment">// 受保护的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except ( <span class="comment">/*异常过滤器exception filter*/</span> ) &#123;</span><br><span class="line">        <span class="comment">// 异常处理程序exception handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="try"><a href="#try" class="headerlink" title="__try"></a>__try</h4><p><code>__try</code>块中包含可能触发异常的代码。如果代码抛出异常，则交由<code>__except</code>块处理。</p>
<h4 id="except"><a href="#except" class="headerlink" title="__except"></a>__except</h4><p><code>__except</code>块中是用户定义的处理异常的代码。</p>
<h4 id="exception-filter"><a href="#exception-filter" class="headerlink" title="exception filter"></a>exception filter</h4><p>exception filter称为异常过滤器。顾名思义，它的作用是对异常进行过滤。</p>
<p>异常过滤器只有三个值（定义在Windows的Excpt.h中）：</p>
<ul>
<li>EXCEPTION_CONTINUE_EXECUTION（-1）<br>在发生异常的地方继续执行。</li>
<li>EXCEPTION_CONTINUE_SEARCH   （0）<br>异常无法识别。继续搜索下一个处理程序。</li>
<li>EXCEPTION_EXECUTE_HANDLER   （1）<br>异常被识别。通过执行控制转移到异常处理程序<code>__except</code>复合语句，然后继续执行<code>__except</code>块。</li>
</ul>
<p>异常过滤器决定了是否处理当前异常，即是否执行<code>__except</code>块中的代码（异常处理程序exception handler）。</p>
<p>异常过滤器的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line">__except ( <span class="built_in">MyFilter</span>( <span class="built_in">GetExceptionCode</span>() ) )</span><br><span class="line">&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">MyFilter</span><span class="params">(DWORD dwExceptionCode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dwExceptionCode == EXCEPTION_ACCESS_VIOLATION )</span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这段代码而言，在异常过滤器中自定义了一个函数<code>MyFilter</code>，以<code>GetExceptionCode()</code>的返回值作为参数，返回值是一个异常过滤器的值，所以也可以直接在<code>__except</code>块的参数中写入异常过滤器的值，如<code>__except (EXCEPTION_EXECUTE_HANDLER) </code>。<br>具体而言，<code>GetExceptionCode()</code>函数返回<code>__try</code>块中产生的异常值（也就是产生异常的原因），据此我们可以实现对异常的过滤。</p>
<p>下表列举操作系统中的异常值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_ACCESS_VIOLATION         0xC0000005     </span><br><span class="line">程序企图读写一个不可访问的地址时引发的异常。例如企图读取0地址处的内存。</span><br><span class="line">EXCEPTION_ARRAY_BOUNDS_EXCEEDED    0xC000008C     </span><br><span class="line">数组访问越界时引发的异常。</span><br><span class="line">EXCEPTION_BREAKPOINT               0x80000003     </span><br><span class="line">触发断点时引发的异常。</span><br><span class="line">EXCEPTION_DATATYPE_MISALIGNMENT    0x80000002     </span><br><span class="line">程序读取一个未经对齐的数据时引发的异常。</span><br><span class="line">EXCEPTION_FLT_DENORMAL_OPERAND     0xC000008D     </span><br><span class="line">如果浮点数操作的操作数是非正常的，则引发该异常。所谓非正常，即它的值太小以至于不能用标准格式表示出来。</span><br><span class="line">EXCEPTION_FLT_DIVIDE_BY_ZERO       0xC000008E     </span><br><span class="line">浮点数除法的除数是0时引发该异常。</span><br><span class="line">EXCEPTION_FLT_INEXACT_RESULT       0xC000008F     </span><br><span class="line">浮点数操作的结果不能精确表示成小数时引发该异常。</span><br><span class="line">EXCEPTION_FLT_INVALID_OPERATION    0xC0000090     </span><br><span class="line">该异常表示不包括在这个表内的其它浮点数异常。</span><br><span class="line">EXCEPTION_FLT_OVERFLOW             0xC0000091     </span><br><span class="line">浮点数的指数超过所能表示的最大值时引发该异常。</span><br><span class="line">EXCEPTION_FLT_STACK_CHECK          0xC0000092     </span><br><span class="line">进行浮点数运算时栈发生溢出或下溢时引发该异常。</span><br><span class="line">EXCEPTION_FLT_UNDERFLOW            0xC0000093     </span><br><span class="line">浮点数的指数小于所能表示的最小值时引发该异常。</span><br><span class="line">EXCEPTION_ILLEGAL_INSTRUCTION      0xC000001D     </span><br><span class="line">程序企图执行一个无效的指令时引发该异常。</span><br><span class="line">EXCEPTION_IN_PAGE_ERROR            0xC0000006     </span><br><span class="line">程序要访问的内存页不在物理内存中时引发的异常。</span><br><span class="line">EXCEPTION_INT_DIVIDE_BY_ZERO       0xC0000094     </span><br><span class="line">整数除法的除数是0时引发该异常。</span><br><span class="line">EXCEPTION_INT_OVERFLOW             0xC0000095     </span><br><span class="line">整数操作的结果溢出时引发该异常。</span><br><span class="line">EXCEPTION_INVALID_DISPOSITION      0xC0000026     </span><br><span class="line">异常处理器返回一个无效的处理的时引发该异常。</span><br><span class="line">EXCEPTION_NONCONTINUABLE_EXCEPTION 0xC0000025     </span><br><span class="line">发生一个不可继续执行的异常时，如果程序继续执行，则会引发该异常。</span><br><span class="line">EXCEPTION_PRIV_INSTRUCTION         0xC0000096     </span><br><span class="line">程序企图执行一条当前CPU模式不允许的指令时引发该异常。</span><br><span class="line">EXCEPTION_SINGLE_STEP              0x80000004     </span><br><span class="line">标志寄存器的TF位为1时，每执行一条指令就会引发该异常。主要用于单步调试。</span><br><span class="line">EXCEPTION_STACK_OVERFLOW           0xC00000FD     </span><br><span class="line">栈溢出时引发该异常。</span><br></pre></td></tr></table></figure>

<p>举例来讲，如果<code>__try</code>块中产生整数除零异常，那么<code>GetExceptionCode()</code>函数返回0xC0000094。自定义过滤器中将这个值与预先设定好的异常值比较。在此例中，这个异常值是EXCEPTION_ACCESS_VIOLATION，即0xC0000005。如果异常值相等，那么就返回EXCEPTION_EXECUTE_HANDLER，进而执行exception handler，也就是使用当前<code>__except</code>块处理异常，否则就返回EXCEPTION_CONTINUE_SEARCH，即继续搜索下一个异常处理程序。</p>
<p>据此，我们就使用自定义的<code>MyFilter</code>完成了对异常的过滤：只有<code>__try</code>块中产生读写不可访问地址异常时，<code>__except</code>块才会处理该异常。也就是说，除了EXCEPTION_ACCESS_VIOLATION这个异常，<code>__except</code>都不会处理。</p>
<p>为了便于理解以上概念，以hgame的creakme2为例说明。</p>
<h3 id="hgame-creakme2"><a href="#hgame-creakme2" class="headerlink" title="hgame creakme2"></a>hgame creakme2</h3><p>这道题是一个xtea的加密，关于这种加密方式不是本文重点，我不细说，主要看SEH的部分。<br>IDA反编译出来的核心加密函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_140001070</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+20h] [rbp-38h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+24h] [rbp-34h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-2Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = *a2;</span><br><span class="line">  v6 = a2[<span class="number">1</span>];</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 += (*(_DWORD *)(a3 + <span class="number">4</span>i64 * (v4 &amp; <span class="number">3</span>)) + v4) ^ (v6 + ((v6 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v6)));</span><br><span class="line">    v4 += dword_140003034;</span><br><span class="line">    v6 += (*(_DWORD *)(a3 + <span class="number">4</span>i64 * ((v4 &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>)) + v4) ^ (v5 + ((v5 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v5)));</span><br><span class="line">  &#125;</span><br><span class="line">  *a2 = v5;</span><br><span class="line">  result = <span class="number">4</span>i64;</span><br><span class="line">  a2[<span class="number">1</span>] = v6;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常按部就班用xtea的解密方式解密出来是一堆乱码，我们有理由怀疑此函数隐藏了一些代码逻辑。去翻一下这个函数的汇编，会发现以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140001112 loc_140001112:                          ; DATA XREF: .rdata:00000001400027C4↓o</span><br><span class="line">.text:0000000140001112                                         ; .rdata:00000001400027D4↓o</span><br><span class="line">.text:0000000140001112 ;   __try &#123; // __except at loc_140001150</span><br><span class="line">.text:0000000140001112 ;     __try &#123; // __except at loc_140001141</span><br><span class="line">.text:0000000140001112                 mov     eax, cs:dword_140003034</span><br><span class="line">.text:0000000140001118                 mov     ecx, [rsp+58h+var_38]</span><br><span class="line">.text:000000014000111C                 add     ecx, eax</span><br><span class="line">.text:000000014000111E                 mov     eax, ecx</span><br><span class="line">.text:0000000140001120                 mov     [rsp+58h+var_38], eax</span><br><span class="line">.text:0000000140001124                 mov     eax, [rsp+58h+var_38]</span><br><span class="line">.text:0000000140001128                 sar     eax, 1Fh</span><br><span class="line">.text:000000014000112B                 mov     [rsp+58h+var_28], eax</span><br><span class="line">.text:000000014000112F                 mov     eax, 1</span><br><span class="line">.text:0000000140001134                 cdq</span><br><span class="line">.text:0000000140001135                 mov     ecx, [rsp+58h+var_28]</span><br><span class="line">.text:0000000140001139                 idiv    ecx</span><br><span class="line">.text:000000014000113B                 mov     [rsp+58h+var_1C], eax</span><br><span class="line">.text:000000014000113F                 jmp     short loc_14000114E</span><br><span class="line">.text:000000014000113F ;     &#125; // starts at 140001112</span><br><span class="line">.text:0000000140001141 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140001141</span><br><span class="line">.text:0000000140001141 loc_140001141:                          ; DATA XREF: .rdata:00000001400027C4↓o</span><br><span class="line">.text:0000000140001141 ;   __except(loc_140001DF6) // owned by 140001112</span><br><span class="line">.text:0000000140001141                 mov     eax, [rsp+58h+var_38]</span><br><span class="line">.text:0000000140001145                 xor     eax, 1234567h</span><br><span class="line">.text:000000014000114A                 mov     [rsp+58h+var_38], eax</span><br><span class="line">.text:000000014000114E</span><br><span class="line">.text:000000014000114E loc_14000114E:                          ; CODE XREF: sub_140001070+CF↑j</span><br><span class="line">.text:000000014000114E                 jmp     short loc_140001158</span><br><span class="line">.text:000000014000114E ;   &#125; // starts at 140001112</span><br><span class="line">.text:0000000140001150 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140001150</span><br><span class="line">.text:0000000140001150 loc_140001150:                          ; DATA XREF: .rdata:00000001400027D4↓o</span><br><span class="line">.text:0000000140001150 ;   __except(loc_140001E21) // owned by 140001112</span><br><span class="line">.text:0000000140001150                 mov     [rsp+58h+var_38], 9E3779B1h</span><br></pre></td></tr></table></figure>

<p>140001112处有两个<code>__try</code>块，分别属于loc_140001150和loc_140001141。<br>我们先去看最内层，双击loc_140001141，IDA跳转到相应地址，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140001141 loc_140001141:                          ; DATA XREF: .rdata:00000001400027C4↓o</span><br><span class="line">.text:0000000140001141 ;   __except(loc_140001DF6) // owned by 140001112</span><br><span class="line">.text:0000000140001141                 mov     eax, [rsp+58h+var_38]</span><br><span class="line">.text:0000000140001145                 xor     eax, 1234567h</span><br><span class="line">.text:000000014000114A                 mov     [rsp+58h+var_38], eax</span><br></pre></td></tr></table></figure>

<p>这里的代码即<code>__except</code>块中处理异常的代码，也就是上面<code>__except</code>大括号中省略号的内容。<br>具体而言，这段代码的作用是每次对xtea加密中的sum值（v4）异或0x1234567。</p>
<p>那么这个异常是如何触发的？双击<code>__except(loc_140001DF6)</code>中的地址loc_140001DF6，按照上文所提及的，这里就是<code>__except</code>块的异常过滤器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140001DF6 ;   __except filter // owned by 140001112</span><br><span class="line">.text:0000000140001DF6                 push    rbp</span><br><span class="line">.text:0000000140001DF8                 sub     rsp, 20h</span><br><span class="line">.text:0000000140001DFC                 mov     rbp, rdx</span><br><span class="line">.text:0000000140001DFF                 mov     [rbp+40h], rcx</span><br><span class="line">.text:0000000140001E03                 mov     rax, [rbp+40h]</span><br><span class="line">.text:0000000140001E07                 mov     rax, [rax]</span><br><span class="line">.text:0000000140001E0A                 mov     eax, [rax]</span><br><span class="line">.text:0000000140001E0C                 mov     [rbp+34h], eax</span><br><span class="line">.text:0000000140001E0F                 mov     eax, [rbp+34h]</span><br><span class="line">.text:0000000140001E12                 mov     ecx, eax</span><br><span class="line">.text:0000000140001E14                 call    sub_140001058</span><br><span class="line">.text:0000000140001E19                 nop</span><br><span class="line">.text:0000000140001E1A                 add     rsp, 20h</span><br><span class="line">.text:0000000140001E1E                 pop     rbp</span><br><span class="line">.text:0000000140001E1F                 retn</span><br></pre></td></tr></table></figure>

<p>可以看到，IDA标注这里是<code>__except filter</code>的内容，不过实际上，这些是为了传递一些异常信息，真正的filter函数在sub_140001058中，也就是这段代码里所调用的一个函数。<br>跳转到这个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140001058 sub_140001058   proc near               ; CODE XREF: sub_140001070+DA4↓p</span><br><span class="line">.text:0000000140001058                                         ; DATA XREF: .pdata:ExceptionDir↓o</span><br><span class="line">.text:0000000140001058                 xor     eax, eax</span><br><span class="line">.text:000000014000105A                 cmp     ecx, 0C0000094h</span><br><span class="line">.text:0000000140001060                 setz    al</span><br><span class="line">.text:0000000140001063                 retn</span><br><span class="line">.text:0000000140001063 sub_140001058   endp</span><br></pre></td></tr></table></figure>
<p>如果反编译一下，发现是retn了奇怪的值，即这里的0xC0000094。对照上文给出的操作系统异常值的表，可以发现这是一个整数除零异常，即EXCEPTION_INT_DIVIDE_BY_ZERO。</p>
<p>不过这样手动去对照异常找比较麻烦，我们可以使用IDA来识别相应的异常，操作如下：<br>选中这个值然后按M，可以选择枚举常量（IDA可能会弹窗，选yes即可），然后可以发现IDA会搜索到异常值。</p>
<p>选择正确的异常值（在我这里是第一个）即可，IDA会将数字转为相应的宏，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140001058 sub_140001058   proc near               ; CODE XREF: sub_140001070+DA4↓p</span><br><span class="line">.text:0000000140001058                                         ; DATA XREF: .pdata:ExceptionDir↓o</span><br><span class="line">.text:0000000140001058                 xor     eax, eax</span><br><span class="line">.text:000000014000105A                 cmp     ecx, EXCEPTION_INT_DIVIDE_BY_ZERO</span><br><span class="line">.text:0000000140001060                 setz    al</span><br><span class="line">.text:0000000140001063                 retn</span><br><span class="line">.text:0000000140001063 sub_140001058   endp</span><br></pre></td></tr></table></figure>

<p>从名字可以看出来，这是一个整数除零异常。外层的loc_140001150处的异常处理分析过程一致，不再赘述，不过外层处理的异常值是0xC0000095，即EXCEPTION_INT_OVERFLOW。这个异常处理中<code>__except</code>块中的内容是每次将0x9E3779B1赋给xtea加密中的sum值（v4）。相应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140001150 loc_140001150:                          ; DATA XREF: .rdata:00000001400027D4↓o</span><br><span class="line">.text:0000000140001150 ;   __except(loc_140001E21) // owned by 140001112</span><br><span class="line">.text:0000000140001150                 mov     [rsp+58h+var_38], 9E3779B1h</span><br></pre></td></tr></table></figure>

<p>分析清楚了两个<code>__except</code>块中的内容，现在我们返回去看<code>__try</code>中的内容。相应代码上面已经贴了，大概意思就是在v4每次加上delta(即dword_140003034)后，计算<code>1/(v4&gt;&gt;31)</code>。这里使用一个变量<code>v4&gt;&gt;31</code>作为分母，当v4首位为0时，就会触发除零异常，执行<code>__except</code>块中的代码，对v4异或0x1234567，以此来魔改加密过程。<br>外层的EXCEPTION_INT_OVERFLOW并没有触发，只是出题人用来迷惑选手的。</p>
<p>出题人在wp中提供的题目源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FilterFuncofDBZ</span><span class="params">(<span class="type">int</span> dwExceptionCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;DIVIDE_BY_ZERO catch\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FilterFuncofOF</span><span class="params">(<span class="type">int</span> dwExceptionCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwExceptionCode == EXCEPTION_INT_OVERFLOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;OVERFLOW catch\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encipher</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_rounds, <span class="type">uint32_t</span> v[<span class="number">2</span>], <span class="type">uint32_t</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_rounds; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        __try &#123;</span><br><span class="line">            __try &#123;</span><br><span class="line">            sum += delta;</span><br><span class="line">            a=<span class="number">1</span> / (sum &gt;&gt; <span class="number">31</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            __except (<span class="built_in">FilterFuncofDBZ</span>(<span class="built_in">GetExceptionCode</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                sum ^= <span class="number">0x1234567</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;__except (<span class="built_in">FilterFuncofOF</span>(<span class="built_in">GetExceptionCode</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0x9E3779B1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%x\n&quot;, sum);</span></span><br><span class="line">    v[<span class="number">0</span>] = v0; v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有难以理解的地方，可以对照源码分析。</p>
<h2 id="SEH深入分析"><a href="#SEH深入分析" class="headerlink" title="SEH深入分析"></a>SEH深入分析</h2><h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>SEH以链的形式存在。第一个异常处理中未处理相关异常，它就会被传递到下一个异常处理器，直到得到处理。<br>SEH链是由<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体组成的链表，此结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> *Next;</span><br><span class="line">    <span class="comment">//指向下一个 EXCEPTION_REGISTRATION_RECORD</span></span><br><span class="line"></span><br><span class="line">    PEXCEPTION_DISPOSITION Handler;  </span><br><span class="line">    <span class="comment">//指向异常处理函数</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD,*PEXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>

<p>如果你有一丢丢数据结构知识，你会发现这是一个最简单的链表结构：一个是元素值，一个是下一个元素的地址。而这里的元素值Handler就存储了当前节点的异常处理函数的地址，Next则指向下一个节点。若Next成员的值为FFFFFFFF，则表示它是链表最后一个结点。</p>
<h3 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h3><p>异常处理函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION __cdecl _except_handler</span><br><span class="line">(</span><br><span class="line">  EXCEPTION_RECORD              *pRecord,</span><br><span class="line">  EXCEPTION_REGISTRATION_RECORD *pFrame,</span><br><span class="line">  CONTEXT                       *pContext,</span><br><span class="line">  PVOID                          pValue</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>异常处理函数接受4个参数输入，这4个参数保存着一些与异常相关的信息。<br>第2个参数EXCEPTION_REGISTRATION_RECORD即是上文提到过的SEH链结构体，第4个参数是OS保留，可以忽略，下面会分析第1和第3个参数。</p>
<p>异常处理函数返回名为EXCEPTION_DISPOSITION的枚举类型，它由系统调用，是一个回调函数。</p>
<h4 id="EXCEPTION-RECORD"><a href="#EXCEPTION-RECORD" class="headerlink" title="EXCEPTION_RECORD"></a>EXCEPTION_RECORD</h4><p>异常处理函数接受的第一个参数是一个指向EXCEPTION_RECORD结构体的指针。<br>EXCEPTION_RECORD定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">  DWORD                    ExceptionCode;<span class="comment">//异常代码</span></span><br><span class="line">  DWORD                    ExceptionFlags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span></span><br><span class="line">  PVOID                    ExceptionAddress;<span class="comment">//异常发生地址</span></span><br><span class="line">  DWORD                    NumberParameters;</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>

<p>ExceptionCode指出异常类型，即上文提到过的一些对应的异常值。<br>ExceptionAddress表示发生异常的代码地址。</p>
<h4 id="CONTEXT"><a href="#CONTEXT" class="headerlink" title="CONTEXT"></a>CONTEXT</h4><p>异常处理函数接受的第三个参数是指向CONTEXT结构体的指针，它用来备份CPU的值。<br>多线程环境下，每个线程内部都有一个CONTEXT结构体。CPU离开当前线程转而运行其他线程时，CPU寄存器的值被保存到当前线程的CONTEXT结构体中，当CPU返回该线程时，使用保存在CONTEXT结构体中的值来覆盖CPU各寄存器的值，以此来保证多线程安全。<br>CONTEXT结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CONTEXT</span> &#123;</span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD   Dr0;                <span class="comment">//0x04</span></span><br><span class="line">    DWORD   Dr1;                <span class="comment">//0x08</span></span><br><span class="line">    DWORD   Dr2;                <span class="comment">//0x0c</span></span><br><span class="line">    DWORD   Dr3;                <span class="comment">//0x10</span></span><br><span class="line">    DWORD   Dr6;                <span class="comment">//0x14</span></span><br><span class="line">    DWORD   Dr7;                <span class="comment">//0x18</span></span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"></span><br><span class="line">    DWORD   SegGs;              <span class="comment">//0x88</span></span><br><span class="line">    DWORD   SegFs;              <span class="comment">//0x90</span></span><br><span class="line">    DWORD   SegEs;              <span class="comment">//0x94</span></span><br><span class="line">    DWORD   SegDs;              <span class="comment">//0x98</span></span><br><span class="line"></span><br><span class="line">    DWORD   Edi;                <span class="comment">//0x9c</span></span><br><span class="line">    DWORD   Esi;                <span class="comment">//0xa0</span></span><br><span class="line">    DWORD   Ebx;                <span class="comment">//0xa4</span></span><br><span class="line">    DWORD   Edx;                <span class="comment">//0xa8</span></span><br><span class="line">    DWORD   Ecx;                <span class="comment">//0xac</span></span><br><span class="line">    DWORD   Eax;                <span class="comment">//0xb0</span></span><br><span class="line">    DWORD   Ebp;                <span class="comment">//0xb4</span></span><br><span class="line">    DWORD   Eip;                <span class="comment">//0xb8</span></span><br><span class="line"></span><br><span class="line">    DWORD   SegCs;              <span class="comment">//0xbc MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">//0xc0 MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;                <span class="comment">//0xc4</span></span><br><span class="line">    DWORD   SegSs;              <span class="comment">//0xc8</span></span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只写了一部分重要的，微软的文档有更新，我还是按照《逆向工程核心原理》这本书上的定义来写，想看最新的定义可以戳<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">这里</a></p>
</blockquote>
<p>注意里面的Eip成员（偏移为0xb8），一般来讲Eip成员应该存储触发异常后的代码地址，即触发异常时的Eip值。<br>具体而言，当某一句代码触发异常，那么Eip的值应该指向这句代码的结束地址。这样当SEH处理完毕异常后，程序可以回到原来的地方，继续执行正常的代码。<br>但是， <strong>在异常处理函数中可能将参数传递过来的CONTEXT.Eip设置为其他地址，然后返回处理函数。</strong> 这样之前暂停的线程会执行新的EIP地址处的代码（反调试中经常使用这个技术）。</p>
<h4 id="EXCEPTION-DISPOSITION"><a href="#EXCEPTION-DISPOSITION" class="headerlink" title="EXCEPTION_DISPOSITION"></a>EXCEPTION_DISPOSITION</h4><p>异常处理函数的返回值是一个EXCEPTION_DISPOSITION的枚举类型，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_EXCEPTION_DISPOSITION</span></span><br><span class="line">&#123;</span><br><span class="line">    ExceptionContinueExecution = <span class="number">0</span>, <span class="comment">//已经处理了异常，回到异常触发点继续执行</span></span><br><span class="line">    ExceptionContinueSearch = <span class="number">1</span>,    <span class="comment">//没有处理异常，继续遍历异常链表</span></span><br><span class="line">    ExceptionNestedException = <span class="number">2</span>,   <span class="comment">//OS内部使用</span></span><br><span class="line">    ExceptionCollidedUnwind = <span class="number">3</span>     <span class="comment">//OS内部使用</span></span><br><span class="line">&#125;EXCEPTION_DISPOSITION;</span><br></pre></td></tr></table></figure>

<h4 id="结构化异常处理内部函数"><a href="#结构化异常处理内部函数" class="headerlink" title="结构化异常处理内部函数"></a>结构化异常处理内部函数</h4><p>了解上述参数的意义和结构之后，如何在源代码(C++)中访问？</p>
<p>结构化异常处理提供了两个可用于 <code>try-except</code> 语句的内部函数： </p>
<ul>
<li><code>GetExceptionCode</code><br>返回 (一个32位整数) 的代码，也就是上文提到过的异常原因相对应的异常值。</li>
<li><code>GetExceptionInformation</code><br>返回一个指向 EXCEPTION_POINTERS 结构的指针，该结构包含有关异常的其他信息。</li>
</ul>
<p>EXCEPTION_POINTERS结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_POINTERS</span> &#123;</span><br><span class="line">  PEXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">  PCONTEXT          ContextRecord;</span><br><span class="line">&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</span><br></pre></td></tr></table></figure>

<p>其中ExceptionRecord是一个指向EXCEPTION_RECORD的指针。<br>ContextRecord是一个指向CONTEXT的指针。</p>
<p>同样，用miniL2021的题目0oooops来帮助理解以上概念。</p>
<h3 id="miniL2021-0oooops"><a href="#miniL2021-0oooops" class="headerlink" title="miniL2021 0oooops"></a>miniL2021 0oooops</h3><p>反编译主函数的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">100</span>]; <span class="comment">// [esp+E0h] [ebp-F0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> Str[<span class="number">104</span>]; <span class="comment">// [esp+14Ch] [ebp-84h] BYREF</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+1B8h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">j_memset</span>(Str, <span class="number">0</span>, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Please input your flag: &quot;</span>);</span><br><span class="line">  <span class="built_in">j_memset</span>(&amp;v4[<span class="number">25</span>], <span class="number">0</span>, <span class="number">0x4B</span>u);</span><br><span class="line">  <span class="built_in">sub_4110DC</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)v4);</span><br><span class="line">  <span class="built_in">sub_411037</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)Str);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)<span class="built_in">sub_4112DA</span>(Str) )</span><br><span class="line">  &#123;</span><br><span class="line">    MEMORY[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ms_exc.registration.TryLevel = <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sub_41126C</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是在IDA里看，可以看到<code>MEMORY[0] = 0;</code>被标着显眼的大红色，这其实是一个很强的提示：即程序中触发了非法内存访问的异常（MEMORY[0]一定是一个非法的地址）。<del>出题人好温柔我真的哭死</del></p>
<p>那么开同步去看这句代码的汇编部分，可以看到显眼的<code>__try</code>块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:00412330 loc_412330:                             ; CODE XREF: _main_0+15C↑j</span><br><span class="line">.text:00412330 ;   __try &#123; // __except at loc_412377</span><br><span class="line">.text:00412330                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00412337                 lea     ebx, [ebp+Str]</span><br><span class="line">.text:0041233D                 xor     eax, eax</span><br><span class="line">.text:0041233F                 db      3Eh</span><br><span class="line">.text:0041233F                 mov     dword ptr [eax], 0</span><br><span class="line">.text:00412346                 mov     edx, 0</span><br><span class="line">.text:0041234B                 div     edx</span><br><span class="line">.text:0041234B ;   &#125; // starts at 412330</span><br></pre></td></tr></table></figure>

<p>分析步骤在上一题中已经详细说过，此处不再赘述。<br>跟进loc_412377后再跟进loc_412356的<code>__except filter</code>，然后跟进<code>sub_411131</code>，此函数经过一次跳转到<code>sub_411DD0</code>。反编译结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">sub_411DD0</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( **(_DWORD **)a2 != <span class="number">-1073741676</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = *(_DWORD *)(*(_DWORD *)(a2 + <span class="number">4</span>) + <span class="number">164</span>) + <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">qmemcpy</span>(v4, <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != ((<span class="type">unsigned</span> __int8)*(_DWORD *)(*(_DWORD *)(a2 + <span class="number">4</span>) + <span class="number">184</span>) ^ ((*(<span class="type">char</span> *)(v5 + <span class="number">2</span> * i + <span class="number">1</span>) ^ <span class="number">0x4D</span>) - <span class="number">4</span>) ^ <span class="number">0x13</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(*(_DWORD *)(a2 + <span class="number">4</span>) + <span class="number">184</span>) += <span class="number">54</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_DWORD *)(*(_DWORD *)(a2 + <span class="number">4</span>) + <span class="number">184</span>) += <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到a2也是一个奇怪的值，按照上文说过的步骤去转成枚举类型，发现这个异常类型是EXCEPTION_INT_DIVIDE_BY_ZERO，即整数除零异常。那么再去看刚开始的<code>__try</code>块中的内容，发现最后两句<code>mov edx, 0</code>和<code>div edx</code>触发了除零异常，那么我们有理由相信这个异常中的函数确实会被调用。</p>
<p>观察这段加密函数，会发现对明文的运算除了一些常规的异或和减法之外，还异或了<code>(unsigned __int8)*(_DWORD *)(*(_DWORD *)(a2 + 4) + 184)</code>这个值。<br>这个操作就是把a2转成DWORD类型后，取偏移为184的地址的值。184的十六进制是0xb8，如果对照上面说过的CONTEXT结构体后面的注释，会发现这个值实际上是Eip的值，即触发异常代码的下一句代码的地址值，取它的最后一字节来异或。<br>那么现在再回去看try块，try块结束的地址是0x41234B，所以这个用来异或的值就是0x4b。</p>
<p>或者也可以根据程序逻辑推知这一点：<br>在验证失败后，执行的代码是<code>*(_DWORD *)(*(_DWORD *)(a2 + 4) + 184) += 54;</code>然后退出程序；验证成功后，执行的代码是<code>*(_DWORD *)(*(_DWORD *)(a2 + 4) + 184) += 63;</code>然后退出程序。<br>上文在CONTEXT里已经强调过，可以通过修改CONTEXT的Eip来控制程序返回的地址。我们有理由相信这两个操作是为了转向不同的结果：即为我们打印失败或成功的信息。所以这里应当修改的是Eip的值，也就是控制程序返回不同的地址。有兴趣可以自行验证这一点。</p>
<p>当然，这样手动找或者推理很麻烦，跟上一题一样，我们还是可以借助IDA来完成这些工作。</p>
<p><code>**(_DWORD **)a2</code>我们已经知道是EXCEPTION_INT_DIVIDE_BY_ZERO，即_EXCEPTION_RECORD中的成员ExceptionCode。<br>上文已经提及过，结构化异常处理内部函数只有<code>GetExceptionCode</code>和<code>GetExceptionInformation</code>。代码中对a2解引用两次才得到ExceptionCode，并且此后有对a2的偏移值有一些操作，所以我们可以推知代码访问使用的函数应该是<code>GetExceptionInformation</code>，而a2则是此函数的返回值类型。<br>具体而言，站在异常的角度来看，a2的数据类型应该是<code>_EXCEPTION_POINTERS *</code>类型的。</p>
<p>在IDA中选中a2，摁Y修改数据类型，输入<code>_EXCEPTION_POINTERS *a2</code>，会发现反编译的代码变成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">sub_411DD0</span><span class="params">(<span class="type">int</span> a1, _EXCEPTION_POINTERS *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h] BYREF</span></span><br><span class="line">  DWORD v5; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a2-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_INT_DIVIDE_BY_ZERO )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = a2-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">qmemcpy</span>(v4, <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != ((<span class="type">unsigned</span> __int8)a2-&gt;ContextRecord-&gt;Eip ^ ((*(<span class="type">char</span> *)(v5 + <span class="number">2</span> * i + <span class="number">1</span>) ^ <span class="number">0x4D</span>) - <span class="number">4</span>) ^ <span class="number">0x13</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a2-&gt;ContextRecord-&gt;Eip += <span class="number">54</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;ContextRecord-&gt;Eip += <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，IDA已经帮我们识别出来了这个值是ContextRecord结构体中的Eip值，我们只需要去看try块的结束地址就能获取到这个值。</p>
<p>也许你会突然想起来，我们最开始找到try块的那个提示非法内存访问的异常呢？上面说过的只是除零异常触发的函数，那么非法内存访问异常有没有触发函数？<br>那当然是有的。上面那个函数里只是奇数处字符的加密函数，偶数处字符的加密函数在TlsCallback_0_0里，可以在IDA的导出表(exports)窗口中找到这个函数，非法内存访问异常触发的函数就在这里。</p>
<blockquote>
<p>TLS，Thread Local Storage 线程局部存储，TLS回调函数的调用运行要先于PE代码执行，该特性使它可以作为一种反调试技术使用。TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据。</p>
</blockquote>
<p>这里涉及到Windows异常处理的另一种机制VEH，由于这个不是本文的重点 <del>（其实是我太菜了不会）</del> ，所以先不细说。对于这个题而言，点进这个函数直接分析即可。<br><a target="_blank" rel="noopener" href="https://blog.trackonyou.top/2021/05/16/a217d1073a20/">track神的博客</a>有讲，感兴趣可以去康康。</p>
<h4 id="两道题目的比较"><a href="#两道题目的比较" class="headerlink" title="两道题目的比较"></a>两道题目的比较</h4><p>最后强调一下这两个题目的一点细微差异：</p>
<p>如果读者还记得我最开始在静态分析中说过的，那么应该知道我强调过一点：<code>__except</code>块中的代码（也就是异常处理程序except handler）中的内容是不能被IDA反编译出来的。<br>在hgame那道题中，我们是通过阅读汇编代码获得的程序逻辑，但在miniL这道题中，我们是看反编译出来的结果，为什么会这样？（能够理解这一点的可以跳过这里）</p>
<p>再来回顾一下<code>__except</code>块中的内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__except ( <span class="comment">/*异常过滤器exception filter*/</span> ) &#123;</span><br><span class="line">        <span class="comment">// 异常处理程序exception handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>__except</code>块中有两个重要的成员：</p>
<ul>
<li>异常过滤器exception filter</li>
<li>异常处理程序exception handler</li>
</ul>
<p>hgame的creakme2将核心代码写入exception handler，也就是<code>__except</code>块大括号包裹的内容，这里的东西是不能够被IDA反编译出来的，所以我们只能通过阅读汇编获得程序逻辑。<br>而miniL的题目则是将核心代码写入exception filter。由于异常过滤器实际上也是一个函数，所以能够被IDA识别并且反编译。</p>
<p>简而言之，如果出题人想考验选手阅读汇编代码的能力，那么就将代码直接写在exception handler中。如果出题人不想为难选手嗯怼汇编，就把代码写入exception filter函数中，或者在exception handler中调用一个写入核心加密过程的函数（这种方法我们将在下一道题中看到）。</p>
<h2 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h2><p>下面要介绍VC++编译器对SEH所做的增强版本，在这之前，先说明一些关于TEB（Thread Environment Block，线程环境块）的知识。在这里只讲解与SEH相关的内容。</p>
<p>TEB成员众多，此处我们只需要了解_NT_TIB。</p>
<h3 id="NT-TIB"><a href="#NT-TIB" class="headerlink" title="_NT_TIB"></a>_NT_TIB</h3><p>TIB（Thread Information Block，线程信息块）<br>_NT_TIB结构体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct	_NT_TIB&#123;</span><br><span class="line">	 struct	_EXCEPTION_REGISTRATION_RECORD *ExceptionList;</span><br><span class="line">	 PVOID StackBase;</span><br><span class="line">	 PVOID StackLimit; </span><br><span class="line">	 PVOID SubSystemTib; </span><br><span class="line">	 union &#123;</span><br><span class="line">		PVOID FiberData; </span><br><span class="line">		DWORD Version;</span><br><span class="line">	 &#125;; </span><br><span class="line">	 PVOID ArbitraryUserPointer;</span><br><span class="line"> 	 struct	_NT_TIB *Self;</span><br><span class="line">&#125; NT_TIB;</span><br><span class="line">typedef NT_TIB *PNT_TIB;</span><br></pre></td></tr></table></figure>

<p>其中ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，也就是SEH链。</p>
<h3 id="TEB访问方法"><a href="#TEB访问方法" class="headerlink" title="TEB访问方法"></a>TEB访问方法</h3><h4 id="Ntdll-NtCurrentTeb"><a href="#Ntdll-NtCurrentTeb" class="headerlink" title="Ntdll.NtCurrentTeb()"></a>Ntdll.NtCurrentTeb()</h4><p>用户模式下使用此函数访问TEB，<code>Ntdll.NtCurrentTeb()</code>返回当前线程的TEB结构体的地址。</p>
<h4 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h4><p><code>FS:[0]</code>指向SEH起始地址。</p>
<h2 id="VC-编译器级的SEH实现"><a href="#VC-编译器级的SEH实现" class="headerlink" title="VC++编译器级的SEH实现"></a>VC++编译器级的SEH实现</h2><p>前述的SEH只是一个简单的模型，只有一个异常链表，这种机制存在很多问题。<br>所以现实程序设计中，大部分采用在VC++6.0中对这个体系进行扩展增强的SEH版本。</p>
<p>编译器提供的增强版本的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION</span> *prev;      <span class="comment">//ebp-0x14</span></span><br><span class="line">　　<span class="type">void</span>                           *handler;   <span class="comment">//ebp-0x0c</span></span><br><span class="line">　　<span class="keyword">struct</span> <span class="title class_">scopetable_entry</span>        *scopetable;<span class="comment">//ebp-8</span></span><br><span class="line"><span class="comment">//类型为 scopetable_entry 的数组</span></span><br><span class="line">　　<span class="type">int</span>                            trylevel;   <span class="comment">//ebp-4</span></span><br><span class="line"><span class="comment">//数组下标，用来索引 scopetable 中的数组成员</span></span><br><span class="line">　　<span class="type">int</span>                            _ebp;       <span class="comment">//ebp</span></span><br><span class="line"><span class="comment">//包含该 _EXCEPTION_REGISTRATION 结构体的函数的栈帧指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原先的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> *Next;</span><br><span class="line">    <span class="comment">//指向下一个 EXCEPTION_REGISTRATION_RECORD</span></span><br><span class="line"></span><br><span class="line">    PEXCEPTION_DISPOSITION Handler;  </span><br><span class="line">    <span class="comment">//指向异常处理函数</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD,*PEXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>

<p>既然是扩展，那么必然保留原来的结构，在此基础上增加一部分内容。进行对比可以发现，前两个结构保留，而最后三个结构是追加的。<br>注释中已经说明，ebp保存函数栈帧；trylevel是一个数组索引，指向<strong>scopetable数组</strong>。</p>
<h3 id="SCOPETABLE"><a href="#SCOPETABLE" class="headerlink" title="_SCOPETABLE"></a>_SCOPETABLE</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SCOPETABLE</span></span><br><span class="line">&#123;</span><br><span class="line">　　 DWORD previousTryLevel; <span class="comment">//定位前一个try块的索引值</span></span><br><span class="line">　　 DWORD lpfnFilter; <span class="comment">//当前try块的过滤函数</span></span><br><span class="line">　　 DWORD lpfnHandler; <span class="comment">//当前try块的终止函数</span></span><br><span class="line">&#125;SCOPETABLE, *PSCOPETABLE;</span><br></pre></td></tr></table></figure>

<h3 id="扩展异常处理机制"><a href="#扩展异常处理机制" class="headerlink" title="扩展异常处理机制"></a>扩展异常处理机制</h3><p>按照原始的设计，每一个<code>__try/__except(__finally)</code> 都应该对应一个 EXCEPTION_REGISTRATION。<br>但是VS实际实现中，每个使用 <code>__try/__except(__finally)</code> 的函数，不管其内部嵌套或反复使用多少 <code>__try/__except(__finally)</code>，都只注册一遍，即只将一个 EXCEPTION_REGISTRATION 挂入当前线程的异常链表中。<br>MSC 提供一个处理函数，即 EXCEPTION_REGISTRATION::handler 被设置为 MSC 的某个函数，而不是我们自己提供的 <code>__except</code> 代码块，我们自己提供的多个 <code>__except</code> 块被存储在 EXCEPTION_REGISTRATION::scopetable 数组中。</p>
<p>乍看这一段话可能会觉得难以理解，我们以SCTF2019的creakme为例进行说明。</p>
<h3 id="SCTF2019-creakme"><a href="#SCTF2019-creakme" class="headerlink" title="SCTF2019 creakme"></a>SCTF2019 creakme</h3><p>主函数太长就不贴出来了，程序的大致流程是在第一个函数中触发一个断点异常，然后在except handler中调用一个用于SMC的函数，在第二个函数中调用这个经过SMC的函数对密文进行一些变换。后来就是对输入进行AES加密，与经过变换的密文比较。我们只说SEH的部分。</p>
<p>查看第一个函数<code>sub_402320</code>的汇编代码（只贴了需要分析的核心内容）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00402320 sub_402320      proc near               ; CODE XREF: _main+35↓p</span><br><span class="line">.text:00402320 ; __unwind &#123; // __except_handler4</span><br><span class="line">.text:00402320                 push    ebp</span><br><span class="line">.text:00402321                 mov     ebp, esp</span><br><span class="line">.text:00402323                 push    0FFFFFFFEh</span><br><span class="line">.text:00402325                 push    offset stru_407B58</span><br><span class="line">.text:0040232A                 push    offset __except_handler4</span><br><span class="line">.text:0040232F                 mov     eax, large fs:0</span><br><span class="line">.text:00402335                 push    eax</span><br></pre></td></tr></table></figure>

<p>对照上文提到过的增强版的SEH结构体，我们可以发现入栈的参数是一一对应的:<br>入栈的参数是ebp、0xFFFFFFFE、stru_407B58、__except_handler4、large fs:0，分别对应_EXCEPTION_REGISTRATION中的_ebp、trylevel、scopetable、handler和prev（前面介绍TEB时已经说过，<code>FS:[0]</code>指向SEH起始地址）。</p>
<p>那么按照scopetable的定义，这个结构体中存储了lpfnFilter（当前try块的过滤函数）和lpfnHandler（当前try块的Handler）。双击stru_407B58，查看这个结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.rdata:00407B58 stru_407B58     dd 0FFFFFFE4h           ; GSCookieOffset</span><br><span class="line">.rdata:00407B58                                         ; DATA XREF: sub_402320+5↑o</span><br><span class="line">.rdata:00407B58                 dd 0                    ; GSCookieXOROffset</span><br><span class="line">.rdata:00407B58                 dd 0FFFFFFC4h           ; EHCookieOffset</span><br><span class="line">.rdata:00407B58                 dd 0                    ; EHCookieXOROffset</span><br><span class="line">.rdata:00407B58                 dd 0FFFFFFFEh           ; ScopeRecord.EnclosingLevel</span><br><span class="line">.rdata:00407B58                 dd offset loc_4023DC    ; ScopeRecord.FilterFunc</span><br><span class="line">.rdata:00407B58                 dd offset loc_4023EF    ; ScopeRecord.HandlerFunc</span><br><span class="line">.rdata:00407B74                 align 8</span><br></pre></td></tr></table></figure>

<p>IDA已经为我们注释出来了，loc_4023DC是FilterFunc，loc_4023EF是HandlerFunc。</p>
<p>先查看FilterFunc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:004023DC loc_4023DC:                             ; DATA XREF: .rdata:stru_407B58↓o</span><br><span class="line">.text:004023DC                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:004023DF                 mov     eax, [eax]</span><br><span class="line">.text:004023E1                 xor     ecx, ecx</span><br><span class="line">.text:004023E3                 cmp     dword ptr [eax], 80000003h</span><br><span class="line">.text:004023E9                 setz    cl</span><br><span class="line">.text:004023EC                 mov     eax, ecx</span><br><span class="line">.text:004023EE                 retn</span><br></pre></td></tr></table></figure>

<p>触发异常的值是0x80000003，使用之前的方法转为枚举类型时，IDA没有搜索出来这个异常类型，但是没有关系，我们可以手动对照一下异常代码表，发现这是一个EXCEPTION_BREAKPOINT，即断点异常。</p>
<p>现在回过头去看sub_402320反编译出来的伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __thiscall <span class="title">sub_402320</span><span class="params">(_DWORD *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int16 v2; <span class="comment">// bx</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="keyword">this</span>[<span class="number">15</span>];</span><br><span class="line">  v2 = *(_WORD *)((<span class="type">char</span> *)<span class="keyword">this</span> + v1 + <span class="number">6</span>);</span><br><span class="line">  v3 = (<span class="type">char</span> *)<span class="keyword">this</span> + v1 + <span class="number">248</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">strcmp</span>(v3, <span class="string">&quot;.SCTF&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">      v5 = v5 &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">DebugBreak</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 += <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，<code>DebugBreak();</code>可以触发断点异常。看其他师傅的博客说这个是通过调试器附加的手段来触发断点异常的 <del>这个我太菜了不会，所以暂且不谈。</del><br>总之结果就是通过这个函数触发了此处的异常。</p>
<p>那么我们返回去看loc_4023EF处的HandlerFunc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:004023EF loc_4023EF:                             ; DATA XREF: .rdata:stru_407B58↓o</span><br><span class="line">.text:004023EF                 mov     esp, [ebp+ms_exc.old_esp]</span><br><span class="line">.text:004023F2                 lea     eax, [ebp+pbDebuggerPresent]</span><br><span class="line">.text:004023F5                 push    eax             ; pbDebuggerPresent</span><br><span class="line">.text:004023F6                 call    ds:GetCurrentProcess</span><br><span class="line">.text:004023FC                 push    eax             ; hProcess</span><br><span class="line">.text:004023FD                 call    ds:CheckRemoteDebuggerPresent</span><br><span class="line">.text:00402403                 call    ds:IsDebuggerPresent</span><br><span class="line">.text:00402409                 test    eax, eax</span><br><span class="line">.text:0040240B                 jnz     short loc_4023B9</span><br><span class="line">.text:0040240D                 cmp     [ebp+pbDebuggerPresent], eax</span><br><span class="line">.text:00402410                 jnz     short loc_4023B9</span><br><span class="line">.text:00402412                 mov     eax, [ebp+var_24]</span><br><span class="line">.text:00402415                 mov     edx, [eax+10h]</span><br><span class="line">.text:00402418                 mov     ecx, [eax+0Ch]</span><br><span class="line">.text:0040241B                 add     ecx, [ebp+var_28]</span><br><span class="line">.text:0040241E                 mov     esi, [ebp+var_2C]</span><br><span class="line">.text:00402421                 lea     edi, [esi+1]</span><br><span class="line">.text:00402424</span><br><span class="line">.text:00402424 loc_402424:                             ; CODE XREF: sub_402320+109↓j</span><br><span class="line">.text:00402424                 mov     al, [esi]</span><br><span class="line">.text:00402426                 inc     esi</span><br><span class="line">.text:00402427                 test    al, al</span><br><span class="line">.text:00402429                 jnz     short loc_402424</span><br><span class="line">.text:0040242B                 sub     esi, edi</span><br><span class="line">.text:0040242D                 push    esi</span><br><span class="line">.text:0040242E                 push    ecx</span><br><span class="line">.text:0040242F                 call    sub_402450</span><br><span class="line">.text:00402434                 add     esp, 8</span><br><span class="line">.text:00402437                 jmp     short loc_4023B9</span><br></pre></td></tr></table></figure>

<p>前面写了一堆反调（<code>CheckRemoteDebuggerPresent</code>、<code>IsDebuggerPresent</code>），后面调用了一个函数<code>sub_402450</code>，跟进这个函数看看，F5反编译出来伪代码，可以发现就是用于SMC的代码。</p>
<p>这道题目的SEH分析过程到此结束，但是上面还有一个问题：MSC提供唯一一个handler处理函数到底是怎么回事？</p>
<p>现在再回去看<code>sub_402320</code>的汇编代码，入栈的第四个参数__except_handler4，之前说过，对应_EXCEPTION_REGISTRATION中的handler，这个函数就是MSC提供的唯一一个EXCEPTION_REGISTRATION::handler处理函数。</p>
<p>我们返回<code>sub_402320</code>，双击__except_handler4，查看汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:004033DE SEH_402320:</span><br><span class="line">.text:004033DE                 push    ebp</span><br><span class="line">.text:004033DF                 mov     ebp, esp</span><br><span class="line">.text:004033E1                 push    [ebp+arg_C]</span><br><span class="line">.text:004033E4                 push    [ebp+arg_8]</span><br><span class="line">.text:004033E7                 push    [ebp+arg_4]</span><br><span class="line">.text:004033EA                 push    [ebp+arg_0]</span><br><span class="line">.text:004033ED                 push    offset @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">.text:004033F2                 push    offset ___security_cookie</span><br><span class="line">.text:004033F7                 call    _except_handler4_common</span><br><span class="line">.text:004033FC                 add     esp, 18h</span><br><span class="line">.text:004033FF                 pop     ebp</span><br><span class="line">.text:00403400                 retn</span><br><span class="line">.text:00403400 __except_handler4 endp</span><br></pre></td></tr></table></figure>

<p>既然这是每一个异常的EXCEPTION_REGISTRATION::handler都会被设置的函数，那么通过这个函数，我们应该可以找到程序中的所有<code>__except</code>块。</p>
<p>选中<code>SEH_402320</code>，摁X查看交叉引用，可以发现在所有向上引用中，除了我们上文提到过的<code>sub_402320</code>，还有一个<code>sub_4024A0</code>也引用了这个函数。<br>在<code>sub_4024A0</code>中分析except块，过程与上面一致，此处不再说明。阅读汇编会发现，<code>sub_4024A0</code>的except实际上什么也没干。对照源码（上面已经给出链接），我们可以证实这一点。</p>
<p>完结撒花！(bushi<br>第一次写这种文章，如果有错误欢迎指出~</p>

    </div>

    <div class="about">
        <h1>关于本文</h1>
        <p>本文作者 云之君, 许可由 <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>

    
        
    
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/CTF" class="item">CTF</a>
                
                <a href="/Learn" class="item">Learn</a>
                
                <a href="/Diary" class="item">Diary</a>
                
                <a href="/friends" class="item">Friends</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/YunZh1Jun" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://space.bilibili.com/25320847" class="item">Bilibili</a>
                
                <a href="mailto:yunzh1jun@qq.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 云之君<br >驱动由 <a href="http://hexo.io/" target="_blank">Hexo</a></span>
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
    </body>
</html>