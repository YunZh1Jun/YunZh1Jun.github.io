<!DOCTYPE html>
<html lang="zh-cn">
    <!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>密码学习 - 云之君&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/img/fav/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
<link rel="stylesheet" href="/css/waline.css">

  
  
  
<link rel="stylesheet" href="/css/post.css">

  

  
    
<script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
 
  

  
<meta name="generator" content="Hexo 5.4.2"></head>
    <body data-color-scheme="auto">
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">云之君&#39;s Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">主页</a>
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/CTF">CTF</a>
            
            
            
            <a class="nav-item" href="/Learn">Learn</a>
            
            
            
            <a class="nav-item" href="/Dairy">Dairy</a>
            
            
            
            <a class="nav-item" href="/Alkaid">Alkaid</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/YunZh1Jun" target="_blank">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        <article class="post">
    <div class="meta">
        
        <div class="date" id="date">
            
            
            
            <span>March</span>
            
            
            
            
            
            
            
            
            
            
            <span>27,</span>
            <span>2022</span>
        </div>
        

        <h2 class="title">密码学习</h2>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>公式渲染有点寄。。。。。总之是一堆问题。。。等有闲心了再整………………</p>
<p>记录一些可能会用到的密码。</p>
<span id="more"></span>

<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h3><p>加密函数：$E(x)=(ax+b)(mod \quad m)$，其中</p>
<ul>
<li>X表示明文按照某种编码得到的数字</li>
<li>a和m互质</li>
<li>m是编码系统中字母的数目</li>
</ul>
<p><a href="/img/code/crypto_code/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81enc.py">加密</a></p>
<p>解密函数： $D(x)=a^{-1}(x-b)(mod \quad m)$<br>其中$a^{-1}$是a对m的乘法逆元，即<code>gmpy2.invert(a,m)</code><br>注意$a^{-1}$在括号外，不同于加密函数</p>
<p><a href="/img/code/crypto_code/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81dec.py">解密</a></p>
<h3 id="Playfair"><a href="#Playfair" class="headerlink" title="Playfair"></a>Playfair</h3><p>加密方法如下：<br>1.选取一串英文字母，除去重复出现的字母，将剩下的字母逐个逐个加入 5 × 5 的矩阵内，剩下的空间由未加入的英文字母依 a-z 的顺序加入。注意，将 q 去除，或将 i 和 j 视作同一字。<br>2.将要加密的明文分成两个一组。若组内的字母相同，将 X（或 Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入 X 。<br>3.在每组中，找出两个字母在矩阵中的地方。<br>4.若两个字母不同行也不同列，在矩阵中找出另外两个字母（第一个字母对应行优先），使这四个字母成为一个长方形的四个角。</p>
<ul>
<li>若两个字母同行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）。</li>
<li>若两个字母同列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）。</li>
<li>新找到的两个字母就是原本的两个字母加密的结果。</li>
</ul>
<h3 id="Polybius-棋盘密码"><a href="#Polybius-棋盘密码" class="headerlink" title="Polybius/棋盘密码"></a>Polybius/棋盘密码</h3><p>常用码表：</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>2</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I/J</td>
<td>K</td>
</tr>
<tr>
<td>3</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td>P</td>
</tr>
<tr>
<td>4</td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
</tr>
<tr>
<td>5</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
</tr>
</tbody></table>
<p>使用5个字符作为密文，每一个明文字母加密得到两个字符。所以其特征是密文只有5个字符，且加密后的密文长度是明文的2倍。</p>
<h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p><strong>破译维吉尼亚密码的关键在于它的密钥是循环重复的。</strong> 关于密钥长度，可以使用卡西斯基实验和弗里德曼实验来取。</p>
<h3 id="曲路密码"><a href="#曲路密码" class="headerlink" title="曲路密码"></a>曲路密码</h3><p>事先约定密钥（行列数以及曲路路径）。按照规定行列填入明文，按照曲路路径顺序写出密文。</p>
<h3 id="列位移加密"><a href="#列位移加密" class="headerlink" title="列位移加密"></a>列位移加密</h3><p>将明文填入表（约定行列数），按照密钥字母顺序进行编号，按此顺序写出明文列，作为密文。</p>
<h3 id="01248密码-云影密码"><a href="#01248密码-云影密码" class="headerlink" title="01248密码/云影密码"></a>01248密码/云影密码</h3><p>0表示间隔，其他数字相加表示在1-26中的字母下标。</p>
<h3 id="键盘类"><a href="#键盘类" class="headerlink" title="键盘类"></a>键盘类</h3><h4 id="手机键盘"><a href="#手机键盘" class="headerlink" title="手机键盘"></a>手机键盘</h4><p>用手机键盘上的两位数字表示字母。<br>加密方式不可能以1开头，第二位数字不可能超过4。</p>
<h4 id="电脑键盘坐标"><a href="#电脑键盘坐标" class="headerlink" title="电脑键盘坐标"></a>电脑键盘坐标</h4><p>三行字母，一个字母被加密成两个数字，即所在列和所在行。</p>
<h4 id="电脑键盘QWE"><a href="#电脑键盘QWE" class="headerlink" title="电脑键盘QWE"></a>电脑键盘QWE</h4><p>即用字母序代替键盘序。</p>
<h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><p>流密码一般逐字节或者逐比特处理信息。流加密目前来说都是对称加密。一般来说</p>
<ul>
<li>流密码的密钥长度会与明文的长度相同。</li>
<li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li>
</ul>
<h3 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h3><p>伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成接近于绝对随机数序列的数字序列的算法。</p>
<p>定义 PRNG 的周期如下：对于一个 PRNG 的<strong>所有可能起始状态</strong>，不重复序列的最长长度。显然，对于一个 PRNG 来说，其周期不会大于其所有可能的状态。但是，需要注意的是，并不是当我们遇到重复的输出时，就可以认为是 PRNG 的周期，因为 PRNG 的状态一般都是大于输出的位数的。</p>
<h3 id="线性同余生成器-LCG"><a href="#线性同余生成器-LCG" class="headerlink" title="线性同余生成器(LCG)"></a>线性同余生成器(LCG)</h3><p>递归公式：$S_{n+1}=aS_{n}+b(mod \quad m)$<br>若$gcd(a,m)=1$，则周期$T=ordm(a)$<br>所以选取系数时应尽量使得a为模m的原根，以此尽量延长LCG的周期。</p>
<p><a href="/img/code/crypto_code/LCG.py">LCG</a></p>
<p><del>cao……突然发现就是当时moe密码的三个线性同余方程……离谱</del> dbtyyds!</p>
<p>基本上就是已知之后的随机数，求个初始值。<br>求出来a和b就可以……或者像dbt那道题根本不用求b……</p>
<p>或者考虑<a target="_blank" rel="noopener" href="https://ctf-wiki.org/crypto/streamcipher/lcg/challenge/">CTFwiki上的解法</a>，根据模数和前两次随机数逆推出初始状态。<br>即<strong>依次从低比特位枚举到高比特位获取初始状态值</strong>，这个思路是基于以下观察：</p>
<ul>
<li>a + b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为第 i 比特位进行运算时，只有可能收到低比特位的进位数值。</li>
<li>a - b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为第 i 比特位进行运算时，只有可能向低比特位的借位。</li>
<li>a * b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可以视作多次加法。</li>
<li>a % b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可视为多次进行减法。</li>
<li>a ^ b = c，c 的第 i 比特位的值只受 a 和 b 该比特位的影响。</li>
</ul>
<p>思路如下：<br>1.依次从低比特位到高比特位依次枚举第一次迭代后的 x 的相应比特位。<br>2.根据自己枚举的值分别计算出第二次的值，只有当对应比特位正确，可以将其加入候选正确值。需要注意的是，这里由于取模，所以我们需要枚举到底减了多少次。<br>3.此外，在最终判断时，仍然需要确保对应的值满足一定要求，因为之前对减了多少次进行了枚举。</p>
<p><a href="/img/code/crypto_code/LCG_test.py">题目</a></p>
<h3 id="线性反馈移位寄存器-LFSR"><a href="#线性反馈移位寄存器-LFSR" class="headerlink" title="线性反馈移位寄存器(LFSR)"></a>线性反馈移位寄存器(LFSR)</h3><p>这直接看<a target="_blank" rel="noopener" href="https://ctf-wiki.org/crypto/streamcipher/fsr/lfsr/">wiki</a>和<a target="_blank" rel="noopener" href="https://www.trackonyou.top/2021/05/22/%E3%80%8CNOTES-02%E3%80%8DStreamCipher-%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/">track神的博客</a>吧<br><del>一个一个抄公式太累了……</del></p>
<p>几点个人理解：<br>反馈函数：$a_{i+n}=\displaystyle \sum^{n}<em>{j=1}{c</em>{j}a_{i+n-j}}$<br>其中，$c_{j}$均在某个有限域$F_{q}$中。<br>有限数域一般是$GF(2)$，即只含有0, 1两个数。<br>实际代码实现中，用逐位异或可以代替加法和乘法，即取$a_{i+n}$的逐比特异或。</p>
<p><a href="/img/code/crypto_code/LFSR.py">实现代码</a><br><a href="/img/code/crypto_code/LFSRwp.py">题解</a></p>
<h3 id="RC系列"><a href="#RC系列" class="headerlink" title="RC系列"></a>RC系列</h3><h4 id="RC2"><a href="#RC2" class="headerlink" title="RC2"></a>RC2</h4><p><a target="_blank" rel="noopener" href="https://people.csail.mit.edu/rivest/pubs/KRRR98.pdf">参考资料</a></p>
<h5 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h5><p>$T(1\leqslant T\leqslant128)$字节密钥，置于数组$L[T-1]$中，使用一个固定的P盒。</p>
<ol>
<li>for $i =T,T+1,…,127$ do<br> $L[i]=P[L[i-1]+L[i-T]]$</li>
<li>$L[128-T8]=P[L[128-T8] &amp; TM]$</li>
<li>for $i=127-T8,…,0$ do<br> $L[i]=P[L[i+1] \bigoplus L[i+T8]]$</li>
<li>$K[i]=L[2i]+L[2i+1]&lt;&lt;8$</li>
</ol>
<p>最终有64字节密钥$K[64]$用于加密。</p>
<h5 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h5><p>一次4字节加密，记为$R[4]$，分MIX和MASH两个过程。</p>
<ul>
<li>MIX<br>  定义$s[4]={1,2,3,5}$<br>  $R[i]=R[i]+K[j]+(R[i-1]&amp;R[i-2])+($~$R[i-1]&amp;R[i-3])$<br>  $j+=1$<br>  $R[i]=R[i]&lt;&lt;&lt;s[i]$</li>
<li>MIXING<br>  $R[i]=R[i]+K[R[i-1]&amp;0x3f]$</li>
</ul>
<h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>RC4使用一个长度为256的s_box，一个长度任意的密钥（不大于256）。密钥的主要功能是将s_box搅乱，i保证s_box的每个元素都得到处理，j保证s_box的搅乱是随机的。将s_box与明文异或，得到密文。解密过程也完全相同。</p>
<p><a href="/img/code/crypto_code/RC4.c">RC4</a></p>
<h4 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a>RC5</h4><h5 id="密钥扩展-1"><a href="#密钥扩展-1" class="headerlink" title="密钥扩展"></a>密钥扩展</h5><ul>
<li>w - 一个字的长度（以bit为单位)，通常是16、32或64。加密以两个字为单位进行。</li>
<li>u＝w/8-一个字的长度，以字节为单位。</li>
<li>b-密钥的长度，字节为单位。</li>
<li>K[]-密钥，可以看作是一个由字节数据组成的数组(下标从0开始)。</li>
<li>c - 密钥的长度，以字为单位(如果b=0，取1).</li>
<li>L[] - 一个在密钥生成的临时数组，用来按字初始化密钥</li>
<li>r - 加密的轮数。</li>
<li>t=2(r+1) - 需要的轮加密的子密钥个数。</li>
<li>S[] - 伪随机S数组。</li>
</ul>
<p>不同w对应不同的$P_{w}$和$Q_{w}$。</p>
<table>
<thead>
<tr>
<th>$w$</th>
<th>$P_{w}$</th>
<th>$Q_{w}$</th>
</tr>
</thead>
<tbody><tr>
<td>16</td>
<td>0xB7E1</td>
<td>0x9E37</td>
</tr>
<tr>
<td>32</td>
<td>0xB7E15163</td>
<td>0x9E3779B9</td>
</tr>
<tr>
<td>64</td>
<td>0xB7E151628AED2A6B</td>
<td>0x9E3779B97F4A7C15</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RC5_SETUP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *K)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// w = 32, r = 12, b = 16</span></span><br><span class="line">   <span class="comment">// c = max(1, ceil(8 * b/w))</span></span><br><span class="line">   <span class="comment">// t = 2 * (r+1)</span></span><br><span class="line">   WORD i, j, k, u = w/<span class="number">8</span>, A, B, L[c];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(i = b<span class="number">-1</span>, L[c<span class="number">-1</span>] = <span class="number">0</span>; i != <span class="number">-1</span>; i--)</span><br><span class="line">      L[i/u] = (L[i/u] &lt;&lt; <span class="number">8</span>) + K[i];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(S[<span class="number">0</span>] = P, i = <span class="number">1</span>; i &lt; t; i++)</span><br><span class="line">      S[i] = S[i<span class="number">-1</span>] + Q;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(A = B = i = j = k = <span class="number">0</span>; k &lt; <span class="number">3</span> * t; k++, i = (i+<span class="number">1</span>) % t, j = (j+<span class="number">1</span>) % c)</span><br><span class="line">   &#123;</span><br><span class="line">      A = S[i] = ROTL(S[i] + (A + B), <span class="number">3</span>);</span><br><span class="line">      B = L[j] = ROTL(L[j] + (A + B), (A + B));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h5><p>建议12或20轮。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROTL(x,y) ((x<span class="string">&lt;&lt;(y&amp;0x3f))|(x&gt;</span>&gt;(64-y&amp;0x3f)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROTR(x,y) ((x&gt;&gt;(y&amp;0x3f))|(x&lt;&lt;(64-y&amp;0x3f)))</span></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC5_ENCRYPT</span><span class="params">(WORD *pt, WORD *ct)</span></span><br><span class="line">&#123;</span><br><span class="line">   WORD i, A = pt[<span class="number">0</span>] + S[<span class="number">0</span>], B = pt[<span class="number">1</span>] + S[<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      A = ROTL(A ^ B, B) + S[<span class="number">2</span>*i];</span><br><span class="line">      B = ROTL(B ^ A, A) + S[<span class="number">2</span>*i + <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   ct[<span class="number">0</span>] = A; ct[<span class="number">1</span>] = B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC5_DECRYPT</span><span class="params">(WORD *ct, WORD *pt)</span></span><br><span class="line">&#123;</span><br><span class="line">   WORD i, B=ct[<span class="number">1</span>], A=ct[<span class="number">0</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(i = r; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line">      B = ROTR(B - S[<span class="number">2</span>*i + <span class="number">1</span>], A) ^ A;</span><br><span class="line">      A = ROTR(A - S[<span class="number">2</span>*i], B) ^ B;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   pt[<span class="number">1</span>] = B - S[<span class="number">1</span>]; pt[<span class="number">0</span>] = A - S[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TEA系列"><a href="#TEA系列" class="headerlink" title="TEA系列"></a>TEA系列</h3><p>一种分组加密算法，此系列算法都使用了一个神秘常数作为倍数，程序中一般写作0x9E3779B9。但有时该常数会以减法的形式出现，即0x61C88647。<br>代码中均使用64bit(8byte)的明文作为加密数据，采用128bit(16byte)的值作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮，这里采用32轮。</p>
<h4 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h4><p><a href="/img/code/crypto_code/TEA.c">TEA</a></p>
<h4 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h4><p>加密逻辑有所变化，对每轮加密的key的选择也有所变化。</p>
<p><a href="/img/code/crypto_code/XTEA.c">XTEA</a></p>
<h4 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h4><p>加密的明文数据可以不再是64bit（两个32位无符号整数），并且其加密轮数是由n即待加密数据个数决定的。由于n决定加密轮数，所以对于多组同时加密的数据不能分开解密，同时分开加密的数据也不能同时解密，要注意是一组数据是一起加密还是分开加密。</p>
<p><a href="/img/code/crypto_code/XXTEA.c">XXTEA</a></p>
<h2 id="块加密"><a href="#块加密" class="headerlink" title="块加密"></a>块加密</h2><p>可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有复杂的加解密算法来加解密明密文。</p>
<p><strong>混淆</strong>，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。<br>一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法：S盒、乘法</p>
<p><strong>扩散</strong>，Diffusion，使得明文中的每一位影响密文中的许多位。<br>常见的方法有：线性变换、置换、移位，循环移位</p>
<h3 id="ARX"><a href="#ARX" class="headerlink" title="ARX"></a>ARX</h3><p>ARX: Add-Rotate-Xor，即</p>
<ul>
<li>Add 有限域上的模加</li>
<li>Rotate 循环移位</li>
<li>Xor 异或<br>执行时间为常数，可以避免基于时间的侧信道攻击，但是Rotate、Xor 对于单个 bit 来说均是完全线性的运算，可能会带来一定的脆弱性。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rotational_cryptanalysis">Rotational cryptanalysis</a></li>
</ul>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>整体流程：<br>64bit划分为左右两部分L和R，R与key作为轮函数Feistel的参数，计算出结果与L异或，再交换左右两部分输出。此步骤进行16轮后，交换左右两部分，输出作为密文。</p>
<p>具体而言，在轮函数Feistel中，R要expand后与key异或，此后经过S盒混淆与P盒扩散，得到最终结果。</p>
<p><strong>expand：</strong> 明文扩展，将32bit明文R扩展为48bit。具体而言，有一个置换表e，将明文中的32bit拆散后按此表的顺序拼接。由于是扩展到48bit，所以有的位会重复利用。<br><strong>轮密钥加：</strong> 扩展后的明文R与key异或。<br><strong>S盒混淆：</strong> 将48bit的字节流拆分为6bit一组，一共8组，在8个大小为64的S盒中查找相应的4bit字节拼接。此步骤将48bit的字节重新还原为32bit。<br><strong>P盒扩散：</strong> 同样是查表替换，按序拼接。<br><strong>密钥扩展：</strong> 使用64bit的key中的56bit，后8位要么丢弃，要么作为校验位。对这64bit密钥查表置换为56bit，然后拆分为左右两部分l和r。<br>循环左移1或2位（根据offset表决定），查表得到48bit的密钥。此步骤重复16轮，得到16轮加密的子密钥。</p>
<p><a href="/img/code/crypto_code/des/des.c">DES</a></p>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>加密64bit数据块，使用128bit长度的密钥，对输入的数据块进行9轮变换。每轮使用6个16bit密钥，最后一轮使用4个。<br>前8个密钥来自初始密钥，从$K_{1}$到$K_{8}$依次从高到低取16bit。密钥循环左移25位获取下一轮密钥，然后再次分为8组</p>
<p>1.对块$X_{1}$与密钥$K_{1}$模乘得到$Y_{1}$，块$X_{3}$与密钥$K_{3}$模加得到$Y_{2}$，两者异或得到$Y_{3}$。<br>2.对块$X_{2}$与密钥$K_{2}$模加得到$Y_{4}$，块$X_{4}$与密钥$K_{4}$模乘得到$Y_{5}$，两者异或得到$Y_{6}$。<br>3.$Y_{3}$与密钥$K_{5}$模乘得到$Y_{7}$，$Y_{7}$与$Y_{6}$模加再与$K_{6}$模乘得到$Y_{8}$，$Y_{8}$与$Y_{7}$模加得到$Y_{9}$。<br>4.$Y_{9}$与$Y_{4}$异或得到$M_{3}$，$Y_{9}$与$Y_{5}$异或得到$M_{4}$，$Y_{8}$与$Y_{2}$异或得到$M_{2}$，$Y_{8}$与$Y_{1}$异或得到$M_{1}$。<br>5.重复7轮上述操作。<br><del>捋一遍真的累死</del><br><img src="/img/code/crypto_code/IDEA.jpg"><br>6.最后一轮中，块$X_{1}$与密钥$K_{1}$模乘得到$M_{1}$，块$X_{2}$与密钥$K_{3}$模加得到$M_{3}$，块$X_{3}$与密钥$K_{2}$模乘得到$M_{2}$，块$X_{4}$与密钥$K_{4}$模乘得到$M_{4}$，<br><img src="/img/code/crypto_code/IDEA2.jpg"></p>
<p>其中模加的模数为$2^{16}$，模乘的模数为$2^{16}+1$。注意0x00的输入会被修改为$2^{16}$，$2^{16}$的输出结果会被修改为0x00。</p>
<p>解密流程的逆元选取：<br>1<del>9轮的解密密钥的前4个子密钥由加密过程中第$10-i$轮的前4个子密钥得出<br>    其中第1个和第4个解密子密钥为相应的子密钥关于$2^{16}+1$的乘法逆元。<br>    第2个和第3个子密钥的取法：<br>        当轮数为2</del>8时，取相应的第3个和第2个的子密钥的$2^{16}$的加密逆元。<br>        当轮数为1或9时，取相应的第2个和第3个子密钥对应的$2^{16}$的加密逆元。<br>    第5和第6个密钥不变。</p>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>明文分块后转为4*4矩阵，一块是128bit，一个元素一字节。其排列顺序顺序为从上到下，从左到右。</p>
<p>1.轮密钥加    </p>
<p>2.1.字节替换<br>    将矩阵中每个字符在S盒中的映射进行替换<br>2.2.行移位<br>    第i行循环左移i位<br>2.3.列混合<br>    每一列乘以一个矩阵，得到新的一列密文<br>2.4.轮密钥加<br>    与轮密钥异或</p>
<p>3.重复2若干轮（10，12，14）</p>
<p>4.1.字节替换<br>4.2.行移位<br>4.3.轮密钥加</p>
<p><a href="/img/code/crypto_code/aes/aes.c">AES</a></p>
<h3 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h3><p>输入4*4字节明文，32轮迭代后输出反序作为密文。<br>每一轮迭代需要4字节轮密钥，迭代过程即是不断使用轮函数F，往后计算下一个字。</p>
<p>例如4字明文$(X_{0},X_{1},X_{2},X_{3})$，一轮迭代后得到$X_{4}=F(X_{0},X_{1},X_{2},X_{3},rk_{0})$<br>二轮迭代即是$X_{5}=F(X_{1},X_{2},X_{3},X_{4},rk_{1})$<br>以此类推，得到$(X_{32},X_{33},X_{34},X_{35})$，输出$(X_{35},X_{34},X_{33},X_{32})$作为密文</p>
<p><strong>轮函数执行的运算为：</strong><br>$F(X_{i},X_{i+1},X_{i+2},X_{i+3},rk_{i})=X_{i} \bigoplus T(X_{i+1}\bigoplus X_{i+2}\bigoplus X_{i+3}\bigoplus rk_{i})$</p>
<p><strong>合成置换T：</strong><br>一字输入A，一字输出C，包含非线性变换$\tau$和线性变换$L$，即$C=L(\tau(A))$</p>
<p><strong>非线性变换$\tau$:</strong><br>对输入的4字节每个字节进行S盒替换</p>
<p><strong>线性变换$L$：</strong><br>$B=L(B)=B \bigoplus (B&lt;&lt;&lt;2) \bigoplus (B&lt;&lt;&lt;10) \bigoplus (B&lt;&lt;&lt;18) \bigoplus (B&lt;&lt;&lt;24)$</p>
<p><strong>密钥扩展：</strong><br><strong>1.异或</strong><br>每个字与系统参数异或得到$(K_{0},K_{1},K_{2},K_{3})$<br>系统参数：$FK_{0}=A3B1BAC6,FK_{1}=56AA3350,FK_{2}=677D9197,FK_{3}=B27022DC$<br><strong>2.轮迭代</strong><br>$rk_{0}=K_{4}=K_{0} \bigoplus T’(K_{1} \bigoplus K_{2} \bigoplus K_{3} \bigoplus CK_{0})$<br>以此类推计算32此轮密钥，其中$T’$类似于T，只是线性变换$L’$有所变化：<br>$L’(B)=B \bigoplus (B&lt;&lt;&lt;13) \bigoplus (B&lt;&lt;&lt;23)$<br><strong>3.计算$CK_{i}$</strong><br>$CK_{i}$长4字节，表示为$(ck_{i,0},ck_{i,1},ck_{i,2},ck_{i,3})$<br>$ck_{i,j}$为第$i$个$CK_{i}$的第$j$个字节，其构造方法为$ck_{i,j}=7(4i+j)(mod \ 256)$<br>即$CK_{i}$实际为一组已知的常量。</p>
<h3 id="Simon-and-Speck"><a href="#Simon-and-Speck" class="headerlink" title="Simon and Speck"></a>Simon and Speck</h3><table>
<thead>
<tr>
<th>Block size(bits)</th>
<th>Key size(bits)</th>
<th>Rounds</th>
</tr>
</thead>
<tbody><tr>
<td>32</td>
<td>64</td>
<td>32</td>
</tr>
<tr>
<td>48</td>
<td>72</td>
<td>36</td>
</tr>
<tr>
<td></td>
<td>96</td>
<td>36</td>
</tr>
<tr>
<td>64</td>
<td>96</td>
<td>42</td>
</tr>
<tr>
<td></td>
<td>128</td>
<td>44</td>
</tr>
<tr>
<td>96</td>
<td>96</td>
<td>52</td>
</tr>
<tr>
<td></td>
<td>144</td>
<td>54</td>
</tr>
<tr>
<td>128</td>
<td>128</td>
<td>68</td>
</tr>
<tr>
<td></td>
<td>192</td>
<td>69</td>
</tr>
<tr>
<td></td>
<td>256</td>
<td>72</td>
</tr>
</tbody></table>
<p>每轮加密算法一样，如下<br><img src="/img/code/crypto_code/Simon.jpg"></p>
<p>当然，对于每一轮以及不同的 m 来说，密钥也会有所不同<br><img src="/img/code/crypto_code/Simon_key.jpg"></p>
<p>其中，$z_{j}$是由LFSR生成的，虽然对于不同的$z_{j}$的逻辑不同，但是初始向量是固定的。</p>
<blockquote>
<p>Constant<br>$z_{0}=11111010001001010110000111001101111101000100101011000011100110$<br>$z_{1}=10001110111110010011000010110101000111011111001001100001011010$<br>$z_{2}=10101111011100000011010010011000101000010001111110010110110011$<br>$z_{3}=11011011101011000110010111100000010010001010011100110100001111$<br>$z_{4}=11010001111001101011011000100000010111000011001010010011101111$</p>
</blockquote>
<p><a href="/img/code/crypto_code/Simon.py">Simon</a></p>
<h3 id="blowfish"><a href="#blowfish" class="headerlink" title="blowfish"></a>blowfish</h3><p><a href="/img/code/crypto_code/blowfish/blowfish.c">blowfish</a></p>
<h2 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h2><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>即使消息的长度是块大小的整数倍，仍然需要填充。<br>一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Padding 是否正确。</p>
<p>1.用缺少的字节数的十六进制填充<br>2.下一个填0x80，往后填0<br>3.填0，最后一个字节填缺少的字节数的十六进制<br>4.全部填0<br>5.空白(0x20)填充</p>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>电子密码本模式(Electronic codebook)，直接划分明文块加密。</p>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>密码分组链接（Cipher-block chaining）</p>
<ul>
<li>IV 不要求保密</li>
<li>IV 必须是不可预测的，而且要保证完整性。</li>
</ul>
<p><img src="/img/code/crypto_code/CBC.jpg"></p>
<p><strong>字节反转攻击：</strong><br>对某个信息已知的原文和密文，修改第$n$个密文块$C_{n}$为$C_{n}\bigoplus P_{n+1}\bigoplus A$，然后解密，那么第$n$个明文块将变成A。</p>
<h3 id="PCBC"><a href="#PCBC" class="headerlink" title="PCBC"></a>PCBC</h3><p>明文密码块链接（Plaintext cipher-block chaining），也称为填充密码块链接（Propagating cipher-block chaining）。</p>
<p><img src="/img/code/crypto_code/PCBC.jpg"></p>
<p>互换邻接的密文块不会对后面的密文块造成影响</p>
<h3 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h3><p>密文反馈模式（Cipher feedback）。</p>
<p><img src="/img/code/crypto_code/CFB.jpg"></p>
<h3 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h3><p>输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。<br><img src="/img/code/crypto_code/OFB.jpg"></p>
<h3 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h3><p>计数器模式（Counter mode）。<br><img src="/img/code/crypto_code/CRT.jpg"></p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><del>咕</del></p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h3 id="MD2"><a href="#MD2" class="headerlink" title="MD2"></a>MD2</h3><p><a href="/img/code/crypto_code/md2/md2.c">MD2</a></p>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p><a href="/img/code/crypto_code/md5/md5.c">MD5</a></p>
<h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><p><a href="/img/code/crypto_code/sha1/sha1.c">SHA1</a></p>
<h3 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h3><p><a href="/img/code/crypto_code/sha256/sha256.c">SHA256</a></p>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p><a href="/img/code/crypto_code/CRC.py">CRC.py</a></p>
<p>常用的CRC码生成多项式：<br>$CRC8=X^8+X^5+X^4+1$<br>$CRC12=X^{12}+X^{11}+X^3+X^2+1$<br>$CRC-CCITT=X^{16}+X^{12}+X^5+1$<br>$CRC16=X^{16}+X^{15}+X^5+1$<br>$CRC32=X^{32}+X^{26}+X^{23}+X^{22}+X^{16}+X^{12}+X^{11}+X^{10}+X^8+X^7+X^5+X^4+X^2+X^{1}+1$</p>
<p>每一个生成多项式都可以与一个代码相对应，如CRC8对应代码：100110001<br>从低位到高位是从0到x(假设是CRCx)</p>
<p>设原始数据为$P$<br>1.找到CRC$x$的对应二进制串crc<br>2.$P$左移$x$位得到$Y$，求$Y$对crc的模2除法的余数（或依次按位异或）得到余数$Q$<br>3.发送$Y \bigoplus Q$，即串$P$追加串$Q$的结果。<br>4.接收端对此串除以crc，余数为0则无差错。</p>

    </div>

    <div class="about">
        <h1>关于本文</h1>
        <p>本文作者 云之君, 许可由 <a
                target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
    </div>

    
        
    
</article>
        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h4 class="title">Blog</h4>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/CTF" class="item">CTF</a>
                
                <a href="/Learn" class="item">Learn</a>
                
                <a href="/Dairy" class="item">Dairy</a>
                
                <a href="/Alkaid" class="item">Alkaid</a>
                
                <a href="/friends" class="item">Friends</a>
                
            </div>
            
            <div class="group">
                <h4 class="title">Me</h4>
                
                <a target="_blank" rel="noopener" href="https://github.com/YunZh1Jun" class="item">GitHub</a>
                
                <a href="mailto:yunzh1jun@qq.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2022 云之君<br >驱动由 <a href="http://hexo.io/" target="_blank">Hexo</a></span>
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
    </body>
</html>